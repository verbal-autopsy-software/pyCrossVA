

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pandas.core.series &mdash; CrossVA 1.0a documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> CrossVA
          

          
          </a>

          
            
            
              <div class="version">
                1.0a
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../about.html">Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../about.html#simple-usage">Simple Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../about.html#currently-supported">Currently Supported</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../about.html#roadmap">Roadmap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../about.html#style">Style</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../about.html#license">License</a></li>
</ul>
<p class="caption"><span class="caption-text">Custom Mappings</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../config.html">Configuration Files</a></li>
</ul>
<p class="caption"><span class="caption-text">Under the hood</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../source/transform.html">transform function</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../source/configuration.html">configuration module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../source/validation.html">validation module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../source/mappings.html">mappings module</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">CrossVA</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>pandas.core.series</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pandas.core.series</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Data structure for 1-dimensional cross-sectional and time series data</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>

<span class="c1"># pylint: disable=E1101,E1103</span>
<span class="c1"># pylint: disable=W0703,W0622,W0613,W0201</span>

<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">textwrap</span> <span class="k">import</span> <span class="n">dedent</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>

<span class="kn">from</span> <span class="nn">pandas.core.accessor</span> <span class="k">import</span> <span class="n">CachedAccessor</span>
<span class="kn">from</span> <span class="nn">pandas.core.arrays</span> <span class="k">import</span> <span class="n">ExtensionArray</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.common</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">is_categorical_dtype</span><span class="p">,</span>
    <span class="n">is_bool</span><span class="p">,</span>
    <span class="n">is_integer</span><span class="p">,</span> <span class="n">is_integer_dtype</span><span class="p">,</span>
    <span class="n">is_float_dtype</span><span class="p">,</span>
    <span class="n">is_extension_type</span><span class="p">,</span>
    <span class="n">is_extension_array_dtype</span><span class="p">,</span>
    <span class="n">is_datetime64tz_dtype</span><span class="p">,</span>
    <span class="n">is_timedelta64_dtype</span><span class="p">,</span>
    <span class="n">is_object_dtype</span><span class="p">,</span>
    <span class="n">is_list_like</span><span class="p">,</span>
    <span class="n">is_hashable</span><span class="p">,</span>
    <span class="n">is_iterator</span><span class="p">,</span>
    <span class="n">is_dict_like</span><span class="p">,</span>
    <span class="n">is_scalar</span><span class="p">,</span>
    <span class="n">_is_unorderable_exception</span><span class="p">,</span>
    <span class="n">_ensure_platform_int</span><span class="p">,</span>
    <span class="n">pandas_dtype</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.generic</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">ABCSparseArray</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">,</span> <span class="n">ABCIndexClass</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.cast</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">maybe_upcast</span><span class="p">,</span> <span class="n">infer_dtype_from_scalar</span><span class="p">,</span>
    <span class="n">maybe_convert_platform</span><span class="p">,</span>
    <span class="n">maybe_cast_to_datetime</span><span class="p">,</span> <span class="n">maybe_castable</span><span class="p">,</span>
    <span class="n">construct_1d_arraylike_from_scalar</span><span class="p">,</span>
    <span class="n">construct_1d_ndarray_preserving_na</span><span class="p">,</span>
    <span class="n">construct_1d_object_array_from_listlike</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.missing</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">isna</span><span class="p">,</span>
    <span class="n">notna</span><span class="p">,</span>
    <span class="n">remove_na_arraylike</span><span class="p">,</span>
    <span class="n">na_value_for_dtype</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">pandas.core.index</span> <span class="k">import</span> <span class="p">(</span><span class="n">Index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">,</span> <span class="n">InvalidIndexError</span><span class="p">,</span>
                               <span class="n">Float64Index</span><span class="p">,</span> <span class="n">_ensure_index</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexing</span> <span class="k">import</span> <span class="n">check_bool_indexer</span><span class="p">,</span> <span class="n">maybe_convert_indices</span>
<span class="kn">from</span> <span class="nn">pandas.core</span> <span class="k">import</span> <span class="n">generic</span><span class="p">,</span> <span class="n">base</span>
<span class="kn">from</span> <span class="nn">pandas.core.internals</span> <span class="k">import</span> <span class="n">SingleBlockManager</span>
<span class="kn">from</span> <span class="nn">pandas.core.arrays.categorical</span> <span class="k">import</span> <span class="n">Categorical</span><span class="p">,</span> <span class="n">CategoricalAccessor</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexes.accessors</span> <span class="k">import</span> <span class="n">CombinedDatetimelikeProperties</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexes.datetimes</span> <span class="k">import</span> <span class="n">DatetimeIndex</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexes.timedeltas</span> <span class="k">import</span> <span class="n">TimedeltaIndex</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexes.period</span> <span class="k">import</span> <span class="n">PeriodIndex</span>
<span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">compat</span>
<span class="kn">from</span> <span class="nn">pandas.io.formats.terminal</span> <span class="k">import</span> <span class="n">get_terminal_size</span>
<span class="kn">from</span> <span class="nn">pandas.compat</span> <span class="k">import</span> <span class="p">(</span>
    <span class="nb">zip</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">,</span> <span class="n">StringIO</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">get_range_parameters</span><span class="p">,</span> <span class="n">PY36</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.compat.numpy</span> <span class="k">import</span> <span class="n">function</span> <span class="k">as</span> <span class="n">nv</span>

<span class="kn">import</span> <span class="nn">pandas.core.ops</span> <span class="k">as</span> <span class="nn">ops</span>
<span class="kn">import</span> <span class="nn">pandas.core.algorithms</span> <span class="k">as</span> <span class="nn">algorithms</span>

<span class="kn">import</span> <span class="nn">pandas.core.common</span> <span class="k">as</span> <span class="nn">com</span>
<span class="kn">import</span> <span class="nn">pandas.core.nanops</span> <span class="k">as</span> <span class="nn">nanops</span>
<span class="kn">import</span> <span class="nn">pandas.io.formats.format</span> <span class="k">as</span> <span class="nn">fmt</span>
<span class="kn">from</span> <span class="nn">pandas.util._decorators</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">Appender</span><span class="p">,</span> <span class="n">deprecate</span><span class="p">,</span> <span class="n">deprecate_kwarg</span><span class="p">,</span> <span class="n">Substitution</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.util._validators</span> <span class="k">import</span> <span class="n">validate_bool_kwarg</span>

<span class="kn">from</span> <span class="nn">pandas._libs</span> <span class="k">import</span> <span class="n">index</span> <span class="k">as</span> <span class="n">libindex</span><span class="p">,</span> <span class="n">tslib</span> <span class="k">as</span> <span class="n">libts</span><span class="p">,</span> <span class="n">lib</span><span class="p">,</span> <span class="n">iNaT</span>
<span class="kn">from</span> <span class="nn">pandas.core.config</span> <span class="k">import</span> <span class="n">get_option</span>
<span class="kn">from</span> <span class="nn">pandas.core.strings</span> <span class="k">import</span> <span class="n">StringMethods</span>

<span class="kn">import</span> <span class="nn">pandas.plotting._core</span> <span class="k">as</span> <span class="nn">gfx</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Series&#39;</span><span class="p">]</span>

<span class="n">_shared_doc_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">axes</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">,</span> <span class="n">klass</span><span class="o">=</span><span class="s1">&#39;Series&#39;</span><span class="p">,</span> <span class="n">axes_single_arg</span><span class="o">=</span><span class="s2">&quot;{0 or &#39;index&#39;}&quot;</span><span class="p">,</span>
    <span class="n">axis</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    axis : {0 or &#39;index&#39;}</span>
<span class="s2">        Parameter needed for compatibility with DataFrame.</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="n">inplace</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;inplace : boolean, default False</span>
<span class="s2">        If True, performs operation inplace and returns None.&quot;&quot;&quot;</span><span class="p">,</span>
    <span class="n">unique</span><span class="o">=</span><span class="s1">&#39;np.ndarray&#39;</span><span class="p">,</span> <span class="n">duplicated</span><span class="o">=</span><span class="s1">&#39;Series&#39;</span><span class="p">,</span>
    <span class="n">optional_by</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">optional_mapper</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">optional_labels</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">optional_axis</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
    <span class="n">versionadded_to_excel</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">    .. versionadded:: 0.20.0</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>


<span class="c1"># see gh-16971</span>
<span class="k">def</span> <span class="nf">remove_na</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Remove null values from array like structure.</span>

<span class="sd">    .. deprecated:: 0.21.0</span>
<span class="sd">        Use s[s.notnull()] instead.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;remove_na is deprecated and is a private &quot;</span>
                  <span class="s2">&quot;function. Do not use.&quot;</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">remove_na_arraylike</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_coerce_method</span><span class="p">(</span><span class="n">converter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; install the scalar coercion methods &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">converter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot convert the series to &quot;</span>
                        <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">converter</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">wrapper</span>

<span class="c1"># ----------------------------------------------------------------------</span>
<span class="c1"># Series class</span>


<span class="k">class</span> <span class="nc">Series</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">IndexOpsMixin</span><span class="p">,</span> <span class="n">generic</span><span class="o">.</span><span class="n">NDFrame</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    One-dimensional ndarray with axis labels (including time series).</span>

<span class="sd">    Labels need not be unique but must be a hashable type. The object</span>
<span class="sd">    supports both integer- and label-based indexing and provides a host of</span>
<span class="sd">    methods for performing operations involving the index. Statistical</span>
<span class="sd">    methods from ndarray have been overridden to automatically exclude</span>
<span class="sd">    missing data (currently represented as NaN).</span>

<span class="sd">    Operations between Series (+, -, /, *, **) align values based on their</span>
<span class="sd">    associated index values-- they need not be the same length. The result</span>
<span class="sd">    index will be the sorted union of the two indexes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array-like, dict, or scalar value</span>
<span class="sd">        Contains data stored in Series</span>

<span class="sd">        .. versionchanged :: 0.23.0</span>
<span class="sd">           If data is a dict, argument order is maintained for Python 3.6</span>
<span class="sd">           and later.</span>

<span class="sd">    index : array-like or Index (1d)</span>
<span class="sd">        Values must be hashable and have the same length as `data`.</span>
<span class="sd">        Non-unique index values are allowed. Will default to</span>
<span class="sd">        RangeIndex (0, 1, 2, ..., n) if not provided. If both a dict and index</span>
<span class="sd">        sequence are used, the index will override the keys found in the</span>
<span class="sd">        dict.</span>
<span class="sd">    dtype : numpy.dtype or None</span>
<span class="sd">        If None, dtype will be inferred</span>
<span class="sd">    copy : boolean, default False</span>
<span class="sd">        Copy input data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_metadata</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
    <span class="n">_accessors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="s1">&#39;dt&#39;</span><span class="p">,</span> <span class="s1">&#39;cat&#39;</span><span class="p">,</span> <span class="s1">&#39;str&#39;</span><span class="p">])</span>
    <span class="n">_deprecations</span> <span class="o">=</span> <span class="n">generic</span><span class="o">.</span><span class="n">NDFrame</span><span class="o">.</span><span class="n">_deprecations</span> <span class="o">|</span> <span class="nb">frozenset</span><span class="p">(</span>
        <span class="p">[</span><span class="s1">&#39;asobject&#39;</span><span class="p">,</span> <span class="s1">&#39;sortlevel&#39;</span><span class="p">,</span> <span class="s1">&#39;reshape&#39;</span><span class="p">,</span> <span class="s1">&#39;get_value&#39;</span><span class="p">,</span> <span class="s1">&#39;set_value&#39;</span><span class="p">,</span>
         <span class="s1">&#39;from_csv&#39;</span><span class="p">,</span> <span class="s1">&#39;valid&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fastpath</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="c1"># we are called internally, so short-circuit</span>
        <span class="k">if</span> <span class="n">fastpath</span><span class="p">:</span>

            <span class="c1"># data is an ndarray, index is defined</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">SingleBlockManager</span><span class="p">):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">SingleBlockManager</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">fastpath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">_ensure_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;initializing a Series from a &quot;</span>
                                          <span class="s2">&quot;MultiIndex is not supported&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">name</span>

                <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># astype copies</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># need to copy to avoid aliasing issues</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">name</span>
                <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_data</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_dict</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">SingleBlockManager</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="ow">or</span> <span class="n">copy</span><span class="p">:</span>
                    <span class="c1"># GH#19275 SingleBlockManager input should only be called</span>
                    <span class="c1"># internally</span>
                    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;Cannot pass both SingleBlockManager &#39;</span>
                                         <span class="s1">&#39;`data` argument and a different &#39;</span>
                                         <span class="s1">&#39;`index` argument.  `copy` must &#39;</span>
                                         <span class="s1">&#39;be False.&#39;</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">is_extension_array_dtype</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">is_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify a dtype &#39;</span><span class="si">{}</span><span class="s2">&#39; with an &quot;</span>
                                     <span class="s2">&quot;extension array of a different &quot;</span>
                                     <span class="s2">&quot;dtype (&#39;</span><span class="si">{}</span><span class="s2">&#39;).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span>
                                                            <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

            <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">GeneratorType</span><span class="p">)</span> <span class="ow">or</span>
                  <span class="p">(</span><span class="n">compat</span><span class="o">.</span><span class="n">PY3</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">map</span><span class="p">))):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="nb">set</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0!r}</span><span class="s2"> type is unordered&quot;</span>
                                <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># handle sparse passed here (and force conversion)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ABCSparseArray</span><span class="p">):</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">to_dense</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">]</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">_default_index</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>

                <span class="c1"># a scalar numpy array is list-like but doesn&#39;t</span>
                <span class="c1"># have a proper length</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s1">&#39;Length of passed values is </span><span class="si">{val}</span><span class="s1">, &#39;</span>
                            <span class="s1">&#39;index implies </span><span class="si">{ind}</span><span class="s1">&#39;</span>
                            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">ind</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)))</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="k">pass</span>

            <span class="c1"># create/copy the manager</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">SingleBlockManager</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span>
                                       <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">copy</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">_sanitize_array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span>
                                       <span class="n">raise_cast_failure</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="n">data</span> <span class="o">=</span> <span class="n">SingleBlockManager</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">fastpath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">generic</span><span class="o">.</span><span class="n">NDFrame</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">fastpath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_axis</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">fastpath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Derive the &quot;_data&quot; and &quot;index&quot; attributes of a new Series from a</span>
<span class="sd">        dictionary input.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : dict or dict-like</span>
<span class="sd">            Data used to populate the new Series</span>
<span class="sd">        index : Index or index-like, default None</span>
<span class="sd">            index for the new Series: if None, use dict keys</span>
<span class="sd">        dtype : dtype, default None</span>
<span class="sd">            dtype for the new Series: if None, infer from data</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        _data : BlockManager for the new Series</span>
<span class="sd">        index : index for the new Series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Looking for NaN in dict doesn&#39;t work ({np.nan : 1}[float(&#39;nan&#39;)]</span>
        <span class="c1"># raises KeyError), so we iterate the entire dict, and align</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">keys</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">compat</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
            <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># fastpath for Series(data=None). Just use broadcasting a scalar</span>
            <span class="c1"># instead of reindexing.</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">na_value_for_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="n">index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">keys</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="c1"># Input is now list-like, so rely on &quot;standard&quot; construction:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">keys</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Now we just make sure the order is respected, if any</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">and</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">PY36</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">)</span> <span class="ow">and</span> <span class="n">data</span><span class="p">:</span>
            <span class="c1"># Need the `and data` to avoid sorting Series(None, index=[...])</span>
            <span class="c1"># since that isn&#39;t really dict-like</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">index</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_array</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">fastpath</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct Series from array.</span>

<span class="sd">        .. deprecated :: 0.23.0</span>
<span class="sd">            Use pd.Series(..) constructor instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;&#39;from_array&#39; is deprecated and will be removed in a &quot;</span>
                      <span class="s2">&quot;future version. Please use the pd.Series(..) &quot;</span>
                      <span class="s2">&quot;constructor instead.&quot;</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">ABCSparseArray</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">pandas.core.sparse.series</span> <span class="k">import</span> <span class="n">SparseSeries</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="n">SparseSeries</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                   <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">fastpath</span><span class="o">=</span><span class="n">fastpath</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Series</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor_expanddim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pandas.core.frame</span> <span class="k">import</span> <span class="n">DataFrame</span>
        <span class="k">return</span> <span class="n">DataFrame</span>

    <span class="c1"># types</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_can_hold_na</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">_can_hold_na</span>

    <span class="n">_index</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_set_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">fastpath</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; override generic, we want to set the _typ here &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">fastpath</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">_ensure_index</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

        <span class="n">is_all_dates</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">is_all_dates</span>
        <span class="k">if</span> <span class="n">is_all_dates</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span>
                              <span class="p">(</span><span class="n">DatetimeIndex</span><span class="p">,</span> <span class="n">PeriodIndex</span><span class="p">,</span> <span class="n">TimedeltaIndex</span><span class="p">)):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">labels</span> <span class="o">=</span> <span class="n">DatetimeIndex</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
                    <span class="c1"># need to set here because we changed the index</span>
                    <span class="k">if</span> <span class="n">fastpath</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
                <span class="k">except</span> <span class="p">(</span><span class="n">libts</span><span class="o">.</span><span class="n">OutOfBoundsDatetime</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                    <span class="c1"># labels may exceeds datetime bounds,</span>
                    <span class="c1"># or not be a DatetimeIndex</span>
                    <span class="k">pass</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_subtyp</span><span class="p">(</span><span class="n">is_all_dates</span><span class="p">)</span>

        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_index&#39;</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">fastpath</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_subtyp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_all_dates</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">is_all_dates</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_subtyp&#39;</span><span class="p">,</span> <span class="s1">&#39;time_series&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_subtyp&#39;</span><span class="p">,</span> <span class="s1">&#39;series&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># we want to call the generic version and not the IndexOpsMixin</span>
        <span class="k">return</span> <span class="n">generic</span><span class="o">.</span><span class="n">NDFrame</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@name</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_hashable</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Series.name must be a hashable type&#39;</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_name&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="c1"># ndarray compatibility</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return the dtype object of the underlying data &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtypes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return the dtype object of the underlying data &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ftype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return if the data is sparse|dense &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">ftype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ftypes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return if the data is sparse|dense &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">ftype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return Series as ndarray or ndarray-like</span>
<span class="sd">        depending on the dtype</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        arr : numpy.ndarray or ndarray-like</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; pd.Series([1, 2, 3]).values</span>
<span class="sd">        array([1, 2, 3])</span>

<span class="sd">        &gt;&gt;&gt; pd.Series(list(&#39;aabc&#39;)).values</span>
<span class="sd">        array([&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;], dtype=object)</span>

<span class="sd">        &gt;&gt;&gt; pd.Series(list(&#39;aabc&#39;)).astype(&#39;category&#39;).values</span>
<span class="sd">        [a, a, b, c]</span>
<span class="sd">        Categories (3, object): [a, b, c]</span>

<span class="sd">        Timezone aware datetime data is converted to UTC:</span>

<span class="sd">        &gt;&gt;&gt; pd.Series(pd.date_range(&#39;20130101&#39;, periods=3,</span>
<span class="sd">        ...                         tz=&#39;US/Eastern&#39;)).values</span>
<span class="sd">        array([&#39;2013-01-01T05:00:00.000000000&#39;,</span>
<span class="sd">               &#39;2013-01-02T05:00:00.000000000&#39;,</span>
<span class="sd">               &#39;2013-01-03T05:00:00.000000000&#39;], dtype=&#39;datetime64[ns]&#39;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">external_values</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return the internal repr of this data &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">internal_values</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_formatting_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the values that can be formatted (used by SeriesFormatter</span>
<span class="sd">        and DataFrameFormatter)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">formatting_values</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; same as values (but handles sparseness conversions); is a view &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get_values</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">asobject</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return object Series which contains boxed values.</span>

<span class="sd">        .. deprecated :: 0.23.0</span>

<span class="sd">           Use ``astype(object)`` instead.</span>

<span class="sd">        *this is an internal non-public method*</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;&#39;asobject&#39; is deprecated. Use &#39;astype(object)&#39;&quot;</span>
                      <span class="s2">&quot; instead&quot;</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>

    <span class="c1"># ops</span>
    <span class="k">def</span> <span class="nf">ravel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the flattened underlying data as an ndarray</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.ndarray.ravel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">compress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return selected slices of an array along given axis as a Series</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.ndarray.compress</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_compress</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">condition</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the *integer* indices of the elements that are non-zero</span>

<span class="sd">        This method is equivalent to calling `numpy.nonzero` on the</span>
<span class="sd">        series data. For compatibility with NumPy, the return value is</span>
<span class="sd">        the same (a tuple with an array of indices for each dimension),</span>
<span class="sd">        but it will always be a one-item tuple because series only have</span>
<span class="sd">        one dimension.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series([0, 3, 0, 4])</span>
<span class="sd">        &gt;&gt;&gt; s.nonzero()</span>
<span class="sd">        (array([1, 3]),)</span>
<span class="sd">        &gt;&gt;&gt; s.iloc[s.nonzero()[0]]</span>
<span class="sd">        1    3</span>
<span class="sd">        3    4</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([0, 3, 0, 4], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])</span>
<span class="sd">        # same return although index of s is different</span>
<span class="sd">        &gt;&gt;&gt; s.nonzero()</span>
<span class="sd">        (array([1, 3]),)</span>
<span class="sd">        &gt;&gt;&gt; s.iloc[s.nonzero()[0]]</span>
<span class="sd">        b    3</span>
<span class="sd">        d    4</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.nonzero</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies the `put` method to its `values` attribute</span>
<span class="sd">        if it has one.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.ndarray.put</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        return the length of the Series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new view of the Series.</span>

<span class="sd">        This function will return a new Series with a view of the same</span>
<span class="sd">        underlying values in memory, optionally reinterpreted with a new data</span>
<span class="sd">        type. The new data type must preserve the same size in bytes as to not</span>
<span class="sd">        cause index misalignment.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : data type</span>
<span class="sd">            Data type object or one of their string representations.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            A new Series object as a view of the same data in memory.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.ndarray.view : Equivalent numpy function to create a new view of</span>
<span class="sd">            the same data in memory.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Series are instantiated with ``dtype=float64`` by default. While</span>
<span class="sd">        ``numpy.ndarray.view()`` will return a view with the same data type as</span>
<span class="sd">        the original array, ``Series.view()`` (without specified dtype)</span>
<span class="sd">        will try using ``float64`` and may fail if the original data type size</span>
<span class="sd">        in bytes is not the same.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series([-2, -1, 0, 1, 2], dtype=&#39;int8&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0   -2</span>
<span class="sd">        1   -1</span>
<span class="sd">        2    0</span>
<span class="sd">        3    1</span>
<span class="sd">        4    2</span>
<span class="sd">        dtype: int8</span>

<span class="sd">        The 8 bit signed integer representation of `-1` is `0b11111111`, but</span>
<span class="sd">        the same bytes represent 255 if read as an 8 bit unsigned integer:</span>

<span class="sd">        &gt;&gt;&gt; us = s.view(&#39;uint8&#39;)</span>
<span class="sd">        &gt;&gt;&gt; us</span>
<span class="sd">        0    254</span>
<span class="sd">        1    255</span>
<span class="sd">        2      0</span>
<span class="sd">        3      1</span>
<span class="sd">        4      2</span>
<span class="sd">        dtype: uint8</span>

<span class="sd">        The views share the same underlying values:</span>

<span class="sd">        &gt;&gt;&gt; us[0] = 128</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0   -128</span>
<span class="sd">        1     -1</span>
<span class="sd">        2      0</span>
<span class="sd">        3      1</span>
<span class="sd">        4      2</span>
<span class="sd">        dtype: int8</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype</span><span class="p">),</span>
                                 <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        the array interface, return my values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_values</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__array_wrap__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets called after a ufunc</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                                 <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array_prepare__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets called prior to a ufunc</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># nice error message for non-ufunc types</span>
        <span class="k">if</span> <span class="n">context</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">context</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{obj}</span><span class="s2"> with dtype </span><span class="si">{dtype}</span><span class="s2"> cannot perform &quot;</span>
                            <span class="s2">&quot;the numpy op </span><span class="si">{op}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">obj</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                <span class="n">dtype</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                <span class="n">op</span><span class="o">=</span><span class="n">context</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># complex</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">real</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">real</span>

    <span class="nd">@real</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">real</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">v</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">imag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">imag</span>

    <span class="nd">@imag</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">imag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="n">v</span>

    <span class="c1"># coercion</span>
    <span class="fm">__float__</span> <span class="o">=</span> <span class="n">_coerce_method</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">__long__</span> <span class="o">=</span> <span class="n">_coerce_method</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="fm">__int__</span> <span class="o">=</span> <span class="n">_coerce_method</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_unpickle_series_compat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;_data&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">index</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>

            <span class="c1"># &lt; 0.12 series pickle</span>

            <span class="n">nd_state</span><span class="p">,</span> <span class="n">own_state</span> <span class="o">=</span> <span class="n">state</span>

            <span class="c1"># recreate the ndarray</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nd_state</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nd_state</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">nd_state</span><span class="p">)</span>

            <span class="c1"># backwards compat</span>
            <span class="n">index</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">own_state</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">own_state</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">own_state</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># recreate</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">SingleBlockManager</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">fastpath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="n">index</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;cannot unpickle legacy formats -&gt; [</span><span class="si">%s</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="n">state</span><span class="p">)</span>

    <span class="c1"># indexers</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of the row axis labels&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_ixs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the i-th value or values in the Series by location</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int, slice, or sequence of integers</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value : scalar (int) or Series (slice, sequence)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>

            <span class="c1"># dispatch to the values if we need</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">libindex</span><span class="o">.</span><span class="n">get_value_at</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">raise</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">_convert_slice_indexer</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;iloc&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_values</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">convert</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">libindex</span><span class="o">.</span><span class="n">get_value_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_mixed_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slobj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">slobj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">_convert_slice_indexer</span><span class="p">(</span><span class="n">slobj</span><span class="p">,</span>
                                                  <span class="n">kind</span><span class="o">=</span><span class="n">kind</span> <span class="ow">or</span> <span class="s1">&#39;getitem&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_values</span><span class="p">(</span><span class="n">slobj</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">_apply_if_callable</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>

                    <span class="c1"># we need to box if loc of the key isn&#39;t scalar here</span>
                    <span class="c1"># otherwise have inline ndarray/lists</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_scalar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">key</span><span class="p">)):</span>
                            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
                                <span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">),</span>
                                <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="k">pass</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">except</span> <span class="n">InvalidIndexError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
                <span class="c1"># kludge</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">key</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>
            <span class="k">elif</span> <span class="n">com</span><span class="o">.</span><span class="n">is_bool_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># we can try to coerce the indexer (or this will raise)</span>
                <span class="n">new_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">_convert_scalar_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">,</span>
                                                             <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;getitem&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">new_key</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">new_key</span><span class="p">)</span>
                <span class="k">raise</span>

        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">raise</span>

        <span class="k">if</span> <span class="n">is_iterator</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">com</span><span class="o">.</span><span class="n">is_bool_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">check_bool_indexer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_with</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="c1"># other: fancy integer or otherwise</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">_convert_slice_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;getitem&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_values</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Indexing a Series with DataFrame is not &#39;</span>
                            <span class="s1">&#39;supported, use the appropriate DataFrame column&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_values_tuple</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_values</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                    <span class="k">raise</span>

            <span class="c1"># pragma: no cover</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Series</span><span class="p">,</span> <span class="n">Index</span><span class="p">)):</span>
                <span class="n">key</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
                <span class="n">key_type</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">inferred_type</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">key_type</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">infer_dtype</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s1">&#39;integer&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_integer</span><span class="p">()</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_floating</span><span class="p">():</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_values</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s1">&#39;boolean&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_values</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># handle the dup indexing case (GH 4246)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="c1"># [slice(0, 5, None)] will break if you convert to ndarray,</span>
                    <span class="c1"># e.g. as requested by np.median</span>
                    <span class="c1"># hack</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">slice</span><span class="p">):</span>
                        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_values</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                    <span class="k">raise</span>

    <span class="k">def</span> <span class="nf">_get_values_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="c1"># mpl hackaround</span>
        <span class="k">if</span> <span class="n">com</span><span class="o">.</span><span class="n">_any_none</span><span class="p">(</span><span class="o">*</span><span class="n">key</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_values</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Can only tuple-index with a MultiIndex&#39;</span><span class="p">)</span>

        <span class="c1"># If key is contained, would have returned by now</span>
        <span class="n">indexer</span><span class="p">,</span> <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc_level</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">indexer</span><span class="p">],</span>
                                 <span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indexer</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get_slice</span><span class="p">(</span><span class="n">indexer</span><span class="p">),</span>
                                     <span class="n">fastpath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">indexer</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">_apply_if_callable</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">setitem</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_with_engine</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">except</span> <span class="n">com</span><span class="o">.</span><span class="n">SettingWithCopyError</span><span class="p">:</span>
                <span class="k">raise</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">is_integer</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">inferred_type</span> <span class="o">==</span> <span class="s1">&#39;integer&#39;</span><span class="p">):</span>

                    <span class="n">values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                    <span class="k">return</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
                    <span class="bp">self</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">value</span>
                    <span class="k">return</span>
                <span class="k">elif</span> <span class="n">com</span><span class="o">.</span><span class="n">is_bool_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                    <span class="k">pass</span>
                <span class="k">elif</span> <span class="n">is_timedelta64_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                    <span class="c1"># reassign a null value to iNaT</span>
                    <span class="k">if</span> <span class="n">isna</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">iNaT</span>

                        <span class="k">try</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">_engine</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span>
                                                         <span class="n">value</span><span class="p">)</span>
                            <span class="k">return</span>
                        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                            <span class="k">pass</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">return</span>

            <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can only tuple-index with a MultiIndex&quot;</span><span class="p">)</span>

                <span class="c1"># python 3 type errors should be raised</span>
                <span class="k">if</span> <span class="n">_is_unorderable_exception</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">com</span><span class="o">.</span><span class="n">is_bool_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">check_bool_indexer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_where</span><span class="p">(</span><span class="o">~</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">return</span>
                <span class="k">except</span> <span class="n">InvalidIndexError</span><span class="p">:</span>
                    <span class="k">pass</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_set_with</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="c1"># do the setitem</span>
        <span class="n">cacher_needs_updating</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_is_chained_assignment_possible</span><span class="p">()</span>
        <span class="n">setitem</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cacher_needs_updating</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_update_cacher</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_set_with_engine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">_engine</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">values</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_set_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># other: fancy integer or otherwise</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">_convert_slice_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;getitem&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_values</span><span class="p">(</span><span class="n">indexer</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_set_values</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">pass</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">Series</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Series</span><span class="p">)):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
                <span class="n">key_type</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">inferred_type</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">key_type</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">infer_dtype</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s1">&#39;integer&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">inferred_type</span> <span class="o">==</span> <span class="s1">&#39;integer&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_set_labels</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_values</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s1">&#39;boolean&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_values</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">),</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_labels</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">_asarray_tuplesafe</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">indexer</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> not contained in the index&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_values</span><span class="p">(</span><span class="n">indexer</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">_values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">setitem</span><span class="p">(</span><span class="n">indexer</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_update_cacher</span><span class="p">()</span>

    <span class="nd">@deprecate_kwarg</span><span class="p">(</span><span class="n">old_arg_name</span><span class="o">=</span><span class="s1">&#39;reps&#39;</span><span class="p">,</span> <span class="n">new_arg_name</span><span class="o">=</span><span class="s1">&#39;repeats&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">repeats</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Repeat elements of an Series. Refer to `numpy.ndarray.repeat`</span>
<span class="sd">        for more information about the `repeats` argument.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.ndarray.repeat</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_repeat</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">repeats</span><span class="p">)</span>
        <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">repeats</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span>
                                 <span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">takeable</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Quickly retrieve single value at passed index label</span>

<span class="sd">        .. deprecated:: 0.21.0</span>
<span class="sd">            Please use .at[] or .iat[] accessors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label : object</span>
<span class="sd">        takeable : interpret the index as indexers, default False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value : scalar value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;get_value is deprecated and will be removed &quot;</span>
                      <span class="s2">&quot;in a future release. Please use &quot;</span>
                      <span class="s2">&quot;.at[] or .iat[] accessors instead&quot;</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">,</span>
                      <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_value</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">takeable</span><span class="o">=</span><span class="n">takeable</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">takeable</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">takeable</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">com</span><span class="o">.</span><span class="n">_maybe_box_datetimelike</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">label</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
    <span class="n">_get_value</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">get_value</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">takeable</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Quickly set single value at passed label. If label is not contained,</span>
<span class="sd">        a new object is created with the label placed at the end of the result</span>
<span class="sd">        index.</span>

<span class="sd">        .. deprecated:: 0.21.0</span>
<span class="sd">            Please use .at[] or .iat[] accessors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label : object</span>
<span class="sd">            Partial indexing with MultiIndex not allowed</span>
<span class="sd">        value : object</span>
<span class="sd">            Scalar value</span>
<span class="sd">        takeable : interpret the index as indexers, default False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        series : Series</span>
<span class="sd">            If label is contained, will be reference to calling Series,</span>
<span class="sd">            otherwise a new object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;set_value is deprecated and will be removed &quot;</span>
                      <span class="s2">&quot;in a future release. Please use &quot;</span>
                      <span class="s2">&quot;.at[] or .iat[] accessors instead&quot;</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">,</span>
                      <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_value</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">takeable</span><span class="o">=</span><span class="n">takeable</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">takeable</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">takeable</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">_engine</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>

            <span class="c1"># set using a non-recursive method</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">return</span> <span class="bp">self</span>
    <span class="n">_set_value</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">set_value</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="k">def</span> <span class="nf">reset_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a new DataFrame or Series with the index reset.</span>

<span class="sd">        This is useful when the index needs to be treated as a column, or</span>
<span class="sd">        when the index is meaningless and needs to be reset to the default</span>
<span class="sd">        before another operation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        level : int, str, tuple, or list, default optional</span>
<span class="sd">            For a Series with a MultiIndex, only remove the specified levels</span>
<span class="sd">            from the index. Removes all levels by default.</span>
<span class="sd">        drop : bool, default False</span>
<span class="sd">            Just reset the index, without inserting it as a column in</span>
<span class="sd">            the new DataFrame.</span>
<span class="sd">        name : object, optional</span>
<span class="sd">            The name to use for the column containing the original Series</span>
<span class="sd">            values. Uses ``self.name`` by default. This argument is ignored</span>
<span class="sd">            when `drop` is True.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            Modify the Series in place (do not create a new object).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            When `drop` is False (the default), a DataFrame is returned.</span>
<span class="sd">            The newly created columns will come first in the DataFrame,</span>
<span class="sd">            followed by the original Series values.</span>
<span class="sd">            When `drop` is True, a `Series` is returned.</span>
<span class="sd">            In either case, if ``inplace=True``, no value is returned.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.reset_index: Analogous function for DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 2, 3, 4], name=&#39;foo&#39;,</span>
<span class="sd">        ...               index=pd.Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], name=&#39;idx&#39;))</span>

<span class="sd">        Generate a DataFrame with default index.</span>

<span class="sd">        &gt;&gt;&gt; s.reset_index()</span>
<span class="sd">          idx  foo</span>
<span class="sd">        0   a    1</span>
<span class="sd">        1   b    2</span>
<span class="sd">        2   c    3</span>
<span class="sd">        3   d    4</span>

<span class="sd">        To specify the name of the new column use `name`.</span>

<span class="sd">        &gt;&gt;&gt; s.reset_index(name=&#39;values&#39;)</span>
<span class="sd">          idx  values</span>
<span class="sd">        0   a       1</span>
<span class="sd">        1   b       2</span>
<span class="sd">        2   c       3</span>
<span class="sd">        3   d       4</span>

<span class="sd">        To generate a new Series with the default set `drop` to True.</span>

<span class="sd">        &gt;&gt;&gt; s.reset_index(drop=True)</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        2    3</span>
<span class="sd">        3    4</span>
<span class="sd">        Name: foo, dtype: int64</span>

<span class="sd">        To update the Series in place, without generating a new one</span>
<span class="sd">        set `inplace` to True. Note that it also requires ``drop=True``.</span>

<span class="sd">        &gt;&gt;&gt; s.reset_index(inplace=True, drop=True)</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        2    3</span>
<span class="sd">        3    4</span>
<span class="sd">        Name: foo, dtype: int64</span>

<span class="sd">        The `level` parameter is interesting for Series with a multi-level</span>
<span class="sd">        index.</span>

<span class="sd">        &gt;&gt;&gt; arrays = [np.array([&#39;bar&#39;, &#39;bar&#39;, &#39;baz&#39;, &#39;baz&#39;]),</span>
<span class="sd">        ...           np.array([&#39;one&#39;, &#39;two&#39;, &#39;one&#39;, &#39;two&#39;])]</span>
<span class="sd">        &gt;&gt;&gt; s2 = pd.Series(</span>
<span class="sd">        ...     range(4), name=&#39;foo&#39;,</span>
<span class="sd">        ...     index=pd.MultiIndex.from_arrays(arrays,</span>
<span class="sd">        ...                                     names=[&#39;a&#39;, &#39;b&#39;]))</span>

<span class="sd">        To remove a specific level from the Index, use `level`.</span>

<span class="sd">        &gt;&gt;&gt; s2.reset_index(level=&#39;a&#39;)</span>
<span class="sd">               a  foo</span>
<span class="sd">        b</span>
<span class="sd">        one  bar    0</span>
<span class="sd">        two  bar    1</span>
<span class="sd">        one  baz    2</span>
<span class="sd">        two  baz    3</span>

<span class="sd">        If `level` is not set, all levels are removed from the Index.</span>

<span class="sd">        &gt;&gt;&gt; s2.reset_index()</span>
<span class="sd">             a    b  foo</span>
<span class="sd">        0  bar  one    0</span>
<span class="sd">        1  bar  two    1</span>
<span class="sd">        2  baz  one    2</span>
<span class="sd">        3  baz  two    3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s1">&#39;inplace&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">drop</span><span class="p">:</span>
            <span class="n">new_index</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">_default_index</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                    <span class="n">level</span> <span class="o">=</span> <span class="p">[</span><span class="n">level</span><span class="p">]</span>
                <span class="n">level</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">_get_level_number</span><span class="p">(</span><span class="n">lev</span><span class="p">)</span> <span class="k">for</span> <span class="n">lev</span> <span class="ow">in</span> <span class="n">level</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">level</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">nlevels</span><span class="p">:</span>
                        <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">droplevel</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">new_index</span>
                <span class="c1"># set name if it was passed, otherwise, keep the previous name</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                                         <span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Cannot reset_index inplace on a Series &#39;</span>
                            <span class="s1">&#39;to create a DataFrame&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_frame</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="n">drop</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__unicode__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a string representation for a particular DataFrame</span>

<span class="sd">        Invoked by unicode(df) in py2 only. Yields a Unicode String in both</span>
<span class="sd">        py2/py3.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">))</span>
        <span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">get_terminal_size</span><span class="p">()</span>
        <span class="n">max_rows</span> <span class="o">=</span> <span class="p">(</span><span class="n">height</span> <span class="k">if</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.max_rows&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span>
                    <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.max_rows&quot;</span><span class="p">))</span>
        <span class="n">show_dimensions</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.show_dimensions&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">buf</span><span class="o">=</span><span class="n">buf</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                       <span class="n">max_rows</span><span class="o">=</span><span class="n">max_rows</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">show_dimensions</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">buf</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">na_rep</span><span class="o">=</span><span class="s1">&#39;NaN&#39;</span><span class="p">,</span> <span class="n">float_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                  <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                  <span class="n">max_rows</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Render a string representation of the Series</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        buf : StringIO-like, optional</span>
<span class="sd">            buffer to write to</span>
<span class="sd">        na_rep : string, optional</span>
<span class="sd">            string representation of NAN to use, default &#39;NaN&#39;</span>
<span class="sd">        float_format : one-parameter function, optional</span>
<span class="sd">            formatter function to apply to columns&#39; elements if they are floats</span>
<span class="sd">            default None</span>
<span class="sd">        header: boolean, default True</span>
<span class="sd">            Add the Series header (index name)</span>
<span class="sd">        index : bool, optional</span>
<span class="sd">            Add index (row) labels, default True</span>
<span class="sd">        length : boolean, default False</span>
<span class="sd">            Add the Series length</span>
<span class="sd">        dtype : boolean, default False</span>
<span class="sd">            Add the Series dtype</span>
<span class="sd">        name : boolean, default False</span>
<span class="sd">            Add the Series name if not None</span>
<span class="sd">        max_rows : int, optional</span>
<span class="sd">            Maximum number of rows to show before truncating. If None, show</span>
<span class="sd">            all.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        formatted : string (if not buffer passed)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">formatter</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">SeriesFormatter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
                                        <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
                                        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">na_rep</span><span class="o">=</span><span class="n">na_rep</span><span class="p">,</span>
                                        <span class="n">float_format</span><span class="o">=</span><span class="n">float_format</span><span class="p">,</span>
                                        <span class="n">max_rows</span><span class="o">=</span><span class="n">max_rows</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">formatter</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>

        <span class="c1"># catch contract violations</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">compat</span><span class="o">.</span><span class="n">text_type</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;result must be of type unicode, type&quot;</span>
                                 <span class="s2">&quot; of result is </span><span class="si">{0!r}</span><span class="s2">&quot;</span>
                                 <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">buf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">buf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Lazily iterate over (index, value) tuples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">),</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="n">items</span> <span class="o">=</span> <span class="n">iteritems</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Misc public methods</span>

    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Alias for index&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">into</span><span class="o">=</span><span class="nb">dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert Series to {label -&gt; value} dict or dict-like object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        into : class, default dict</span>
<span class="sd">            The collections.Mapping subclass to use as the return</span>
<span class="sd">            object. Can be the actual class or an empty</span>
<span class="sd">            instance of the mapping type you want.  If you want a</span>
<span class="sd">            collections.defaultdict, you must pass it initialized.</span>

<span class="sd">            .. versionadded:: 0.21.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value_dict : collections.Mapping</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; s.to_dict()</span>
<span class="sd">        {0: 1, 1: 2, 2: 3, 3: 4}</span>
<span class="sd">        &gt;&gt;&gt; from collections import OrderedDict, defaultdict</span>
<span class="sd">        &gt;&gt;&gt; s.to_dict(OrderedDict)</span>
<span class="sd">        OrderedDict([(0, 1), (1, 2), (2, 3), (3, 4)])</span>
<span class="sd">        &gt;&gt;&gt; dd = defaultdict(list)</span>
<span class="sd">        &gt;&gt;&gt; s.to_dict(dd)</span>
<span class="sd">        defaultdict(&lt;type &#39;list&#39;&gt;, {0: 1, 1: 2, 2: 3, 3: 4})</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># GH16122</span>
        <span class="n">into_c</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">standardize_mapping</span><span class="p">(</span><span class="n">into</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">into_c</span><span class="p">(</span><span class="n">compat</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">to_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert Series to DataFrame</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : object, default None</span>
<span class="sd">            The passed name should substitute for the series name (if it has</span>
<span class="sd">            one).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data_frame : DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_expanddim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_expanddim</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="bp">self</span><span class="p">})</span>

        <span class="k">return</span> <span class="n">df</span>

    <span class="k">def</span> <span class="nf">to_sparse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;block&#39;</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert Series to SparseSeries</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kind : {&#39;block&#39;, &#39;integer&#39;}</span>
<span class="sd">        fill_value : float, defaults to NaN (missing)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sp : SparseSeries</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.sparse.series</span> <span class="k">import</span> <span class="n">SparseSeries</span>
        <span class="k">return</span> <span class="n">SparseSeries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                            <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the Series name.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">        inplace : bool</span>
<span class="sd">            whether to modify `self` directly or return a copy</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s1">&#39;inplace&#39;</span><span class="p">)</span>
        <span class="n">ser</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ser</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">return</span> <span class="n">ser</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Statistics, overridden ndarray methods</span>

    <span class="c1"># TODO: integrate bottleneck</span>

    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return number of non-NA/null observations in the Series</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        level : int or level name, default None</span>
<span class="sd">            If the axis is a MultiIndex (hierarchical), count along a</span>
<span class="sd">            particular level, collapsing into a smaller Series</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nobs : int or Series (if level specified)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">notna</span><span class="p">(</span><span class="n">com</span><span class="o">.</span><span class="n">_values_from_object</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">compat</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
            <span class="n">level</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">_get_level_number</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>

        <span class="n">lev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="n">level</span><span class="p">]</span>
        <span class="n">lab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">level</span><span class="p">],</span> <span class="n">subok</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">lab</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">lab</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">cnt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lev</span><span class="p">)</span>
            <span class="n">lev</span> <span class="o">=</span> <span class="n">lev</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">lev</span><span class="o">.</span><span class="n">_na_value</span><span class="p">)</span>

        <span class="n">obs</span> <span class="o">=</span> <span class="n">lab</span><span class="p">[</span><span class="n">notna</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)]</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">lev</span><span class="p">)</span> <span class="ow">or</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">lev</span><span class="p">,</span>
                                 <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int64&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the mode(s) of the dataset.</span>

<span class="sd">        Always returns Series even if only one value is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        modes : Series (sorted)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Add option for bins like value_counts()</span>
        <span class="k">return</span> <span class="n">algorithms</span><span class="o">.</span><span class="n">mode</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">unique</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return unique values of Series object.</span>

<span class="sd">        Uniques are returned in order of appearance. Hash table-based unique,</span>
<span class="sd">        therefore does NOT sort.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray or Categorical</span>
<span class="sd">            The unique values returned as a NumPy array. In case of categorical</span>
<span class="sd">            data type, returned as a Categorical.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pandas.unique : top-level unique method for any 1-d array-like object.</span>
<span class="sd">        Index.unique : return Index with unique values from an Index object.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; pd.Series([2, 1, 3, 3], name=&#39;A&#39;).unique()</span>
<span class="sd">        array([2, 1, 3])</span>

<span class="sd">        &gt;&gt;&gt; pd.Series([pd.Timestamp(&#39;2016-01-01&#39;) for _ in range(3)]).unique()</span>
<span class="sd">        array([&#39;2016-01-01T00:00:00.000000000&#39;], dtype=&#39;datetime64[ns]&#39;)</span>

<span class="sd">        &gt;&gt;&gt; pd.Series([pd.Timestamp(&#39;2016-01-01&#39;, tz=&#39;US/Eastern&#39;)</span>
<span class="sd">        ...            for _ in range(3)]).unique()</span>
<span class="sd">        array([Timestamp(&#39;2016-01-01 00:00:00-0500&#39;, tz=&#39;US/Eastern&#39;)],</span>
<span class="sd">              dtype=object)</span>

<span class="sd">        An unordered Categorical will return categories in the order of</span>
<span class="sd">        appearance.</span>

<span class="sd">        &gt;&gt;&gt; pd.Series(pd.Categorical(list(&#39;baabc&#39;))).unique()</span>
<span class="sd">        [b, a, c]</span>
<span class="sd">        Categories (3, object): [b, a, c]</span>

<span class="sd">        An ordered Categorical preserves the category ordering.</span>

<span class="sd">        &gt;&gt;&gt; pd.Series(pd.Categorical(list(&#39;baabc&#39;), categories=list(&#39;abc&#39;),</span>
<span class="sd">        ...                          ordered=True)).unique()</span>
<span class="sd">        [b, a, c]</span>
<span class="sd">        Categories (3, object): [a &lt; b &lt; c]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">is_datetime64tz_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="c1"># we are special casing datetime64tz_dtype</span>
            <span class="c1"># to return an object array of tz-aware Timestamps</span>

            <span class="c1"># TODO: it must return DatetimeArray with tz in pandas 2.0</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">drop_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return Series with duplicate values removed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keep : {&#39;first&#39;, &#39;last&#39;, ``False``}, default &#39;first&#39;</span>
<span class="sd">            - &#39;first&#39; : Drop duplicates except for the first occurrence.</span>
<span class="sd">            - &#39;last&#39; : Drop duplicates except for the last occurrence.</span>
<span class="sd">            - ``False`` : Drop all duplicates.</span>
<span class="sd">        inplace : boolean, default ``False``</span>
<span class="sd">            If ``True``, performs operation inplace and returns None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        deduplicated : Series</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Index.drop_duplicates : equivalent method on Index</span>
<span class="sd">        DataFrame.drop_duplicates : equivalent method on DataFrame</span>
<span class="sd">        Series.duplicated : related method on Series, indicating duplicate</span>
<span class="sd">            Series values.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Generate an Series with duplicated entries.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([&#39;lama&#39;, &#39;cow&#39;, &#39;lama&#39;, &#39;beetle&#39;, &#39;lama&#39;, &#39;hippo&#39;],</span>
<span class="sd">        ...               name=&#39;animal&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0      lama</span>
<span class="sd">        1       cow</span>
<span class="sd">        2      lama</span>
<span class="sd">        3    beetle</span>
<span class="sd">        4      lama</span>
<span class="sd">        5     hippo</span>
<span class="sd">        Name: animal, dtype: object</span>

<span class="sd">        With the &#39;keep&#39; parameter, the selection behaviour of duplicated values</span>
<span class="sd">        can be changed. The value &#39;first&#39; keeps the first occurrence for each</span>
<span class="sd">        set of duplicated entries. The default value of keep is &#39;first&#39;.</span>

<span class="sd">        &gt;&gt;&gt; s.drop_duplicates()</span>
<span class="sd">        0      lama</span>
<span class="sd">        1       cow</span>
<span class="sd">        3    beetle</span>
<span class="sd">        5     hippo</span>
<span class="sd">        Name: animal, dtype: object</span>

<span class="sd">        The value &#39;last&#39; for parameter &#39;keep&#39; keeps the last occurrence for</span>
<span class="sd">        each set of duplicated entries.</span>

<span class="sd">        &gt;&gt;&gt; s.drop_duplicates(keep=&#39;last&#39;)</span>
<span class="sd">        1       cow</span>
<span class="sd">        3    beetle</span>
<span class="sd">        4      lama</span>
<span class="sd">        5     hippo</span>
<span class="sd">        Name: animal, dtype: object</span>

<span class="sd">        The value ``False`` for parameter &#39;keep&#39; discards all sets of</span>
<span class="sd">        duplicated entries. Setting the value of &#39;inplace&#39; to ``True`` performs</span>
<span class="sd">        the operation inplace and returns ``None``.</span>

<span class="sd">        &gt;&gt;&gt; s.drop_duplicates(keep=False, inplace=True)</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        1       cow</span>
<span class="sd">        3    beetle</span>
<span class="sd">        5     hippo</span>
<span class="sd">        Name: animal, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="n">keep</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">duplicated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Indicate duplicate Series values.</span>

<span class="sd">        Duplicated values are indicated as ``True`` values in the resulting</span>
<span class="sd">        Series. Either all duplicates, all except the first or all except the</span>
<span class="sd">        last occurrence of duplicates can be indicated.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keep : {&#39;first&#39;, &#39;last&#39;, False}, default &#39;first&#39;</span>
<span class="sd">            - &#39;first&#39; : Mark duplicates as ``True`` except for the first</span>
<span class="sd">              occurrence.</span>
<span class="sd">            - &#39;last&#39; : Mark duplicates as ``True`` except for the last</span>
<span class="sd">              occurrence.</span>
<span class="sd">            - ``False`` : Mark all duplicates as ``True``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        By default, for each set of duplicated values, the first occurrence is</span>
<span class="sd">        set on False and all others on True:</span>

<span class="sd">        &gt;&gt;&gt; animals = pd.Series([&#39;lama&#39;, &#39;cow&#39;, &#39;lama&#39;, &#39;beetle&#39;, &#39;lama&#39;])</span>
<span class="sd">        &gt;&gt;&gt; animals.duplicated()</span>
<span class="sd">        0    False</span>
<span class="sd">        1    False</span>
<span class="sd">        2     True</span>
<span class="sd">        3    False</span>
<span class="sd">        4     True</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        which is equivalent to</span>

<span class="sd">        &gt;&gt;&gt; animals.duplicated(keep=&#39;first&#39;)</span>
<span class="sd">        0    False</span>
<span class="sd">        1    False</span>
<span class="sd">        2     True</span>
<span class="sd">        3    False</span>
<span class="sd">        4     True</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        By using &#39;last&#39;, the last occurrence of each set of duplicated values</span>
<span class="sd">        is set on False and all others on True:</span>

<span class="sd">        &gt;&gt;&gt; animals.duplicated(keep=&#39;last&#39;)</span>
<span class="sd">        0     True</span>
<span class="sd">        1    False</span>
<span class="sd">        2     True</span>
<span class="sd">        3    False</span>
<span class="sd">        4    False</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        By setting keep on ``False``, all duplicates are True:</span>

<span class="sd">        &gt;&gt;&gt; animals.duplicated(keep=False)</span>
<span class="sd">        0     True</span>
<span class="sd">        1    False</span>
<span class="sd">        2     True</span>
<span class="sd">        3    False</span>
<span class="sd">        4     True</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.core.series.Series</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pandas.Index.duplicated : Equivalent method on pandas.Index</span>
<span class="sd">        pandas.DataFrame.duplicated : Equivalent method on pandas.DataFrame</span>
<span class="sd">        pandas.Series.drop_duplicates : Remove duplicate values from Series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="n">keep</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">idxmin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the row label of the minimum value.</span>

<span class="sd">        If multiple values equal the minimum, the first row label with that</span>
<span class="sd">        value is returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        skipna : boolean, default True</span>
<span class="sd">            Exclude NA/null values. If the entire Series is NA, the result</span>
<span class="sd">            will be NA.</span>
<span class="sd">        axis : int, default 0</span>
<span class="sd">            For compatibility with DataFrame.idxmin. Redundant for application</span>
<span class="sd">            on Series.</span>
<span class="sd">        *args, **kwargs</span>
<span class="sd">            Additional keywors have no effect but might be accepted</span>
<span class="sd">            for compatibility with NumPy.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        idxmin : Index of minimum of values.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the Series is empty.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is the Series version of ``ndarray.argmin``. This method</span>
<span class="sd">        returns the label of the minimum, while ``ndarray.argmin`` returns</span>
<span class="sd">        the position. To get the position, use ``series.values.argmin()``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.argmin : Return indices of the minimum values</span>
<span class="sd">            along the given axis.</span>
<span class="sd">        DataFrame.idxmin : Return index of first occurrence of minimum</span>
<span class="sd">            over requested axis.</span>
<span class="sd">        Series.idxmax : Return index *label* of the first occurrence</span>
<span class="sd">            of maximum of values.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series(data=[1, None, 4, 1],</span>
<span class="sd">        ...               index=[&#39;A&#39; ,&#39;B&#39; ,&#39;C&#39; ,&#39;D&#39;])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        A    1.0</span>
<span class="sd">        B    NaN</span>
<span class="sd">        C    4.0</span>
<span class="sd">        D    1.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        &gt;&gt;&gt; s.idxmin()</span>
<span class="sd">        &#39;A&#39;</span>

<span class="sd">        If `skipna` is False and there is an NA value in the data,</span>
<span class="sd">        the function returns ``nan``.</span>

<span class="sd">        &gt;&gt;&gt; s.idxmin(skipna=False)</span>
<span class="sd">        nan</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">skipna</span> <span class="o">=</span> <span class="n">nv</span><span class="o">.</span><span class="n">validate_argmin_with_skipna</span><span class="p">(</span><span class="n">skipna</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">nanops</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">(</span><span class="n">com</span><span class="o">.</span><span class="n">_values_from_object</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">idxmax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the row label of the maximum value.</span>

<span class="sd">        If multiple values equal the maximum, the first row label with that</span>
<span class="sd">        value is returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        skipna : boolean, default True</span>
<span class="sd">            Exclude NA/null values. If the entire Series is NA, the result</span>
<span class="sd">            will be NA.</span>
<span class="sd">        axis : int, default 0</span>
<span class="sd">            For compatibility with DataFrame.idxmax. Redundant for application</span>
<span class="sd">            on Series.</span>
<span class="sd">        *args, **kwargs</span>
<span class="sd">            Additional keywors have no effect but might be accepted</span>
<span class="sd">            for compatibility with NumPy.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        idxmax : Index of maximum of values.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the Series is empty.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is the Series version of ``ndarray.argmax``. This method</span>
<span class="sd">        returns the label of the maximum, while ``ndarray.argmax`` returns</span>
<span class="sd">        the position. To get the position, use ``series.values.argmax()``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.argmax : Return indices of the maximum values</span>
<span class="sd">            along the given axis.</span>
<span class="sd">        DataFrame.idxmax : Return index of first occurrence of maximum</span>
<span class="sd">            over requested axis.</span>
<span class="sd">        Series.idxmin : Return index *label* of the first occurrence</span>
<span class="sd">            of minimum of values.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series(data=[1, None, 4, 3, 4],</span>
<span class="sd">        ...               index=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        A    1.0</span>
<span class="sd">        B    NaN</span>
<span class="sd">        C    4.0</span>
<span class="sd">        D    3.0</span>
<span class="sd">        E    4.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        &gt;&gt;&gt; s.idxmax()</span>
<span class="sd">        &#39;C&#39;</span>

<span class="sd">        If `skipna` is False and there is an NA value in the data,</span>
<span class="sd">        the function returns ``nan``.</span>

<span class="sd">        &gt;&gt;&gt; s.idxmax(skipna=False)</span>
<span class="sd">        nan</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">skipna</span> <span class="o">=</span> <span class="n">nv</span><span class="o">.</span><span class="n">validate_argmax_with_skipna</span><span class="p">(</span><span class="n">skipna</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">nanops</span><span class="o">.</span><span class="n">nanargmax</span><span class="p">(</span><span class="n">com</span><span class="o">.</span><span class="n">_values_from_object</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="c1"># ndarray compat</span>
    <span class="n">argmin</span> <span class="o">=</span> <span class="n">deprecate</span><span class="p">(</span>
        <span class="s1">&#39;argmin&#39;</span><span class="p">,</span> <span class="n">idxmin</span><span class="p">,</span> <span class="s1">&#39;0.21.0&#39;</span><span class="p">,</span>
        <span class="n">msg</span><span class="o">=</span><span class="n">dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">        &#39;argmin&#39; is deprecated, use &#39;idxmin&#39; instead. The behavior of &#39;argmin&#39;</span>
<span class="s2">        will be corrected to return the positional minimum in the future.</span>
<span class="s2">        Use &#39;series.values.argmin&#39; to get the position of the minimum now.&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">argmax</span> <span class="o">=</span> <span class="n">deprecate</span><span class="p">(</span>
        <span class="s1">&#39;argmax&#39;</span><span class="p">,</span> <span class="n">idxmax</span><span class="p">,</span> <span class="s1">&#39;0.21.0&#39;</span><span class="p">,</span>
        <span class="n">msg</span><span class="o">=</span><span class="n">dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">        &#39;argmax&#39; is deprecated, use &#39;idxmax&#39; instead. The behavior of &#39;argmax&#39;</span>
<span class="s2">        will be corrected to return the positional maximum in the future.</span>
<span class="s2">        Use &#39;series.values.argmax&#39; to get the position of the maximum now.&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">round</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Round each value in a Series to the given number of decimals.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        decimals : int</span>
<span class="sd">            Number of decimal places to round to (default: 0).</span>
<span class="sd">            If decimals is negative, it specifies the number of</span>
<span class="sd">            positions to the left of the decimal point.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series object</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.around</span>
<span class="sd">        DataFrame.round</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_round</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">_values_from_object</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">decimals</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">quantile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return value at the given quantile, a la numpy.percentile.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        q : float or array-like, default 0.5 (50% quantile)</span>
<span class="sd">            0 &lt;= q &lt;= 1, the quantile(s) to compute</span>
<span class="sd">        interpolation : {&#39;linear&#39;, &#39;lower&#39;, &#39;higher&#39;, &#39;midpoint&#39;, &#39;nearest&#39;}</span>
<span class="sd">            .. versionadded:: 0.18.0</span>

<span class="sd">            This optional parameter specifies the interpolation method to use,</span>
<span class="sd">            when the desired quantile lies between two data points `i` and `j`:</span>

<span class="sd">                * linear: `i + (j - i) * fraction`, where `fraction` is the</span>
<span class="sd">                  fractional part of the index surrounded by `i` and `j`.</span>
<span class="sd">                * lower: `i`.</span>
<span class="sd">                * higher: `j`.</span>
<span class="sd">                * nearest: `i` or `j` whichever is nearest.</span>
<span class="sd">                * midpoint: (`i` + `j`) / 2.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        quantile : float or Series</span>
<span class="sd">            if ``q`` is an array, a Series will be returned where the</span>
<span class="sd">            index is ``q`` and the values are the quantiles.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = Series([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; s.quantile(.5)</span>
<span class="sd">        2.5</span>
<span class="sd">        &gt;&gt;&gt; s.quantile([.25, .5, .75])</span>
<span class="sd">        0.25    1.75</span>
<span class="sd">        0.50    2.50</span>
<span class="sd">        0.75    3.25</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pandas.core.window.Rolling.quantile</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_percentile</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">qs</span><span class="o">=</span><span class="n">q</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span>
                                     <span class="n">index</span><span class="o">=</span><span class="n">Float64Index</span><span class="p">(</span><span class="n">q</span><span class="p">),</span>
                                     <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># scalar</span>
            <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">corr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;pearson&#39;</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute correlation with `other` Series, excluding missing values</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Series</span>
<span class="sd">        method : {&#39;pearson&#39;, &#39;kendall&#39;, &#39;spearman&#39;}</span>
<span class="sd">            * pearson : standard correlation coefficient</span>
<span class="sd">            * kendall : Kendall Tau correlation coefficient</span>
<span class="sd">            * spearman : Spearman rank correlation</span>
<span class="sd">        min_periods : int, optional</span>
<span class="sd">            Minimum number of observations needed to have a valid result</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        correlation : float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">nanops</span><span class="o">.</span><span class="n">nancorr</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                              <span class="n">min_periods</span><span class="o">=</span><span class="n">min_periods</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cov</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute covariance with Series, excluding missing values</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Series</span>
<span class="sd">        min_periods : int, optional</span>
<span class="sd">            Minimum number of observations needed to have a valid result</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        covariance : float</span>

<span class="sd">        Normalized by N-1 (unbiased estimator).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">nanops</span><span class="o">.</span><span class="n">nancov</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                             <span class="n">min_periods</span><span class="o">=</span><span class="n">min_periods</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        First discrete difference of element.</span>

<span class="sd">        Calculates the difference of a Series element compared with another</span>
<span class="sd">        element in the Series (default is element in previous row).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        periods : int, default 1</span>
<span class="sd">            Periods to shift for calculating difference, accepts negative</span>
<span class="sd">            values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        diffed : Series</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.pct_change: Percent change over given number of periods.</span>
<span class="sd">        Series.shift: Shift index by desired number of periods with an</span>
<span class="sd">            optional time freq.</span>
<span class="sd">        DataFrame.diff: First discrete difference of object</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Difference with previous row</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 1, 2, 3, 5, 8])</span>
<span class="sd">        &gt;&gt;&gt; s.diff()</span>
<span class="sd">        0    NaN</span>
<span class="sd">        1    0.0</span>
<span class="sd">        2    1.0</span>
<span class="sd">        3    1.0</span>
<span class="sd">        4    2.0</span>
<span class="sd">        5    3.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        Difference with 3rd previous row</span>

<span class="sd">        &gt;&gt;&gt; s.diff(periods=3)</span>
<span class="sd">        0    NaN</span>
<span class="sd">        1    NaN</span>
<span class="sd">        2    NaN</span>
<span class="sd">        3    2.0</span>
<span class="sd">        4    4.0</span>
<span class="sd">        5    6.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        Difference with following row</span>

<span class="sd">        &gt;&gt;&gt; s.diff(periods=-1)</span>
<span class="sd">        0    0.0</span>
<span class="sd">        1   -1.0</span>
<span class="sd">        2   -1.0</span>
<span class="sd">        3   -2.0</span>
<span class="sd">        4   -3.0</span>
<span class="sd">        5    NaN</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">algorithms</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">com</span><span class="o">.</span><span class="n">_values_from_object</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">periods</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">autocorr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Lag-N autocorrelation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lag : int, default 1</span>
<span class="sd">            Number of lags to apply before performing autocorrelation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        autocorr : float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">lag</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Matrix multiplication with DataFrame or inner-product with Series</span>
<span class="sd">        objects. Can also be called using `self @ other` in Python &gt;= 3.5.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Series or DataFrame</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dot_product : scalar or Series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.frame</span> <span class="k">import</span> <span class="n">DataFrame</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">)):</span>
            <span class="n">common</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">common</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">common</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;matrices are not aligned&#39;</span><span class="p">)</span>

            <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">common</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">common</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">lvals</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">values</span>
            <span class="n">rvals</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">lvals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>
            <span class="n">rvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">lvals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">rvals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Dot product shape mismatch, </span><span class="si">%s</span><span class="s1"> vs </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
                                <span class="p">(</span><span class="n">lvals</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">rvals</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">lvals</span><span class="p">,</span> <span class="n">rvals</span><span class="p">),</span>
                                     <span class="n">index</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">lvals</span><span class="p">,</span> <span class="n">rvals</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rvals</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">lvals</span><span class="p">,</span> <span class="n">rvals</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;unsupported type: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__matmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Matrix multiplication using binary `@` operator in Python&gt;=3.5 &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rmatmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Matrix multiplication using binary `@` operator in Python&gt;=3.5 &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="nd">@Substitution</span><span class="p">(</span><span class="n">klass</span><span class="o">=</span><span class="s1">&#39;Series&#39;</span><span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;searchsorted&#39;</span><span class="p">])</span>
    <span class="nd">@deprecate_kwarg</span><span class="p">(</span><span class="n">old_arg_name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="n">new_arg_name</span><span class="o">=</span><span class="s1">&#39;value&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">sorter</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sorter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sorter</span> <span class="o">=</span> <span class="n">_ensure_platform_int</span><span class="p">(</span><span class="n">sorter</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">Series</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span>
                                         <span class="n">side</span><span class="o">=</span><span class="n">side</span><span class="p">,</span> <span class="n">sorter</span><span class="o">=</span><span class="n">sorter</span><span class="p">)</span>

    <span class="c1"># -------------------------------------------------------------------</span>
    <span class="c1"># Combination</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_append</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verify_integrity</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concatenate two or more Series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        to_append : Series or list/tuple of Series</span>
<span class="sd">        ignore_index : boolean, default False</span>
<span class="sd">            If True, do not use the index labels.</span>

<span class="sd">            .. versionadded:: 0.19.0</span>

<span class="sd">        verify_integrity : boolean, default False</span>
<span class="sd">            If True, raise Exception on creating index with duplicates</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Iteratively appending to a Series can be more computationally intensive</span>
<span class="sd">        than a single concatenate. A better solution is to append values to a</span>
<span class="sd">        list and then concatenate the list with the original Series all at</span>
<span class="sd">        once.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        pandas.concat : General function to concatenate DataFrame, Series</span>
<span class="sd">            or Panel objects</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        appended : Series</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s1 = pd.Series([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; s2 = pd.Series([4, 5, 6])</span>
<span class="sd">        &gt;&gt;&gt; s3 = pd.Series([4, 5, 6], index=[3,4,5])</span>
<span class="sd">        &gt;&gt;&gt; s1.append(s2)</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        2    3</span>
<span class="sd">        0    4</span>
<span class="sd">        1    5</span>
<span class="sd">        2    6</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; s1.append(s3)</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        2    3</span>
<span class="sd">        3    4</span>
<span class="sd">        4    5</span>
<span class="sd">        5    6</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        With `ignore_index` set to True:</span>

<span class="sd">        &gt;&gt;&gt; s1.append(s2, ignore_index=True)</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        2    3</span>
<span class="sd">        3    4</span>
<span class="sd">        4    5</span>
<span class="sd">        5    6</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        With `verify_integrity` set to True:</span>

<span class="sd">        &gt;&gt;&gt; s1.append(s2, verify_integrity=True)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        ValueError: Indexes have overlapping values: [0, 1, 2]</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.reshape.concat</span> <span class="k">import</span> <span class="n">concat</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">to_append</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">to_concat</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="n">to_append</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">to_concat</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_append</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">concat</span><span class="p">(</span><span class="n">to_concat</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="n">ignore_index</span><span class="p">,</span>
                      <span class="n">verify_integrity</span><span class="o">=</span><span class="n">verify_integrity</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_binop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform generic binary operation with optional fill value</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Series</span>
<span class="sd">        func : binary operator</span>
<span class="sd">        fill_value : float or object</span>
<span class="sd">            Value to substitute for NA/null values. If both Series are NA in a</span>
<span class="sd">            location, the result will be NA regardless of the passed fill value</span>
<span class="sd">        level : int or level name, default None</span>
<span class="sd">            Broadcast across a level, matching Index values on the</span>
<span class="sd">            passed MultiIndex level</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        combined : Series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;Other operand must be Series&#39;</span><span class="p">)</span>

        <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span>
        <span class="n">this</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
            <span class="n">this</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">,</span>
                                     <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">new_index</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">index</span>

        <span class="n">this_vals</span><span class="p">,</span> <span class="n">other_vals</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">fill_binop</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                                               <span class="n">fill_value</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">this_vals</span><span class="p">,</span> <span class="n">other_vals</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">get_op_result_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># When name is None, __finalize__ overwrites current name</span>
            <span class="n">result</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">combine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform elementwise binary operation on two Series using given function</span>
<span class="sd">        with optional fill value when an index is missing from one Series or</span>
<span class="sd">        the other</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Series or scalar value</span>
<span class="sd">        func : function</span>
<span class="sd">            Function that takes two scalars as inputs and return a scalar</span>
<span class="sd">        fill_value : scalar value</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : Series</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s1 = Series([1, 2])</span>
<span class="sd">        &gt;&gt;&gt; s2 = Series([0, 3])</span>
<span class="sd">        &gt;&gt;&gt; s1.combine(s2, lambda x1, x2: x1 if x1 &lt; x2 else x2)</span>
<span class="sd">        0    0</span>
<span class="sd">        1    2</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.combine_first : Combine Series values, choosing the calling</span>
<span class="sd">            Series&#39;s values first</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
            <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="n">new_name</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">get_op_result_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_index</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_index</span><span class="p">):</span>
                <span class="n">lv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
                <span class="n">rv</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
                <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                    <span class="n">new_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">lv</span><span class="p">,</span> <span class="n">rv</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                <span class="n">new_values</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
            <span class="n">new_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">new_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">combine_first</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Combine Series values, choosing the calling Series&#39;s values</span>
<span class="sd">        first. Result index will be the union of the two indexes</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Series</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        combined : Series</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s1 = pd.Series([1, np.nan])</span>
<span class="sd">        &gt;&gt;&gt; s2 = pd.Series([3, 4])</span>
<span class="sd">        &gt;&gt;&gt; s1.combine_first(s2)</span>
<span class="sd">        0    1.0</span>
<span class="sd">        1    4.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.combine : Perform elementwise operation on two Series</span>
<span class="sd">            using a given function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="n">this</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">new_index</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">new_index</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># TODO: do we need name?</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">get_op_result_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>  <span class="c1"># noqa</span>
        <span class="n">rs_vals</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">_where_compat</span><span class="p">(</span><span class="n">isna</span><span class="p">(</span><span class="n">this</span><span class="p">),</span> <span class="n">other</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">this</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">rs_vals</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modify Series in place using non-NA values from passed</span>
<span class="sd">        Series. Aligns on index</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Series</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; s.update(pd.Series([4, 5, 6]))</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    4</span>
<span class="sd">        1    5</span>
<span class="sd">        2    6</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
<span class="sd">        &gt;&gt;&gt; s.update(pd.Series([&#39;d&#39;, &#39;e&#39;], index=[0, 2]))</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    d</span>
<span class="sd">        1    b</span>
<span class="sd">        2    e</span>
<span class="sd">        dtype: object</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; s.update(pd.Series([4, 5, 6, 7, 8]))</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    4</span>
<span class="sd">        1    5</span>
<span class="sd">        2    6</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        If ``other`` contains NaNs the corresponding values are not updated</span>
<span class="sd">        in the original Series.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; s.update(pd.Series([4, np.nan, 6]))</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    4</span>
<span class="sd">        1    2</span>
<span class="sd">        2    6</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">reindex_like</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">notna</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_update_cacher</span><span class="p">()</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Reindexing, sorting</span>

    <span class="k">def</span> <span class="nf">sort_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;quicksort&#39;</span><span class="p">,</span> <span class="n">na_position</span><span class="o">=</span><span class="s1">&#39;last&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort by the values.</span>

<span class="sd">        Sort a Series in ascending or descending order by some</span>
<span class="sd">        criterion.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {0 or &#39;index&#39;}, default 0</span>
<span class="sd">            Axis to direct sorting. The value &#39;index&#39; is accepted for</span>
<span class="sd">            compatibility with DataFrame.sort_values.</span>
<span class="sd">        ascending : bool, default True</span>
<span class="sd">            If True, sort values in ascending order, otherwise descending.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            If True, perform operation in-place.</span>
<span class="sd">        kind : {&#39;quicksort&#39;, &#39;mergesort&#39; or &#39;heapsort&#39;}, default &#39;quicksort&#39;</span>
<span class="sd">            Choice of sorting algorithm. See also :func:`numpy.sort` for more</span>
<span class="sd">            information. &#39;mergesort&#39; is the only stable  algorithm.</span>
<span class="sd">        na_position : {&#39;first&#39; or &#39;last&#39;}, default &#39;last&#39;</span>
<span class="sd">            Argument &#39;first&#39; puts NaNs at the beginning, &#39;last&#39; puts NaNs at</span>
<span class="sd">            the end.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            Series ordered by values.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.sort_index : Sort by the Series indices.</span>
<span class="sd">        DataFrame.sort_values : Sort DataFrame by the values along either axis.</span>
<span class="sd">        DataFrame.sort_index : Sort DataFrame by indices.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series([np.nan, 1, 3, 10, 5])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0     NaN</span>
<span class="sd">        1     1.0</span>
<span class="sd">        2     3.0</span>
<span class="sd">        3     10.0</span>
<span class="sd">        4     5.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        Sort values ascending order (default behaviour)</span>

<span class="sd">        &gt;&gt;&gt; s.sort_values(ascending=True)</span>
<span class="sd">        1     1.0</span>
<span class="sd">        2     3.0</span>
<span class="sd">        4     5.0</span>
<span class="sd">        3    10.0</span>
<span class="sd">        0     NaN</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        Sort values descending order</span>

<span class="sd">        &gt;&gt;&gt; s.sort_values(ascending=False)</span>
<span class="sd">        3    10.0</span>
<span class="sd">        4     5.0</span>
<span class="sd">        2     3.0</span>
<span class="sd">        1     1.0</span>
<span class="sd">        0     NaN</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        Sort values inplace</span>

<span class="sd">        &gt;&gt;&gt; s.sort_values(ascending=False, inplace=True)</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        3    10.0</span>
<span class="sd">        4     5.0</span>
<span class="sd">        2     3.0</span>
<span class="sd">        1     1.0</span>
<span class="sd">        0     NaN</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        Sort values putting NAs first</span>

<span class="sd">        &gt;&gt;&gt; s.sort_values(na_position=&#39;first&#39;)</span>
<span class="sd">        0     NaN</span>
<span class="sd">        1     1.0</span>
<span class="sd">        2     3.0</span>
<span class="sd">        4     5.0</span>
<span class="sd">        3    10.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        Sort a series of strings</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([&#39;z&#39;, &#39;b&#39;, &#39;d&#39;, &#39;a&#39;, &#39;c&#39;])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    z</span>
<span class="sd">        1    b</span>
<span class="sd">        2    d</span>
<span class="sd">        3    a</span>
<span class="sd">        4    c</span>
<span class="sd">        dtype: object</span>

<span class="sd">        &gt;&gt;&gt; s.sort_values()</span>
<span class="sd">        3    a</span>
<span class="sd">        1    b</span>
<span class="sd">        4    c</span>
<span class="sd">        2    d</span>
<span class="sd">        0    z</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s1">&#39;inplace&#39;</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="c1"># GH 5856/5853</span>
        <span class="k">if</span> <span class="n">inplace</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_cached</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This Series is a view of some other array, to &quot;</span>
                             <span class="s2">&quot;sort in-place you must create a copy&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_try_kind_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
            <span class="c1"># easier to ask forgiveness than permission</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># if kind==mergesort, it can fail for object dtype</span>
                <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c1"># stable sort not available for object dtype</span>
                <span class="c1"># uses the argsort default quicksort</span>
                <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;quicksort&#39;</span><span class="p">)</span>

        <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span>
        <span class="n">sortedIdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="n">bad</span> <span class="o">=</span> <span class="n">isna</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

        <span class="n">good</span> <span class="o">=</span> <span class="o">~</span><span class="n">bad</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">_default_index</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="n">argsorted</span> <span class="o">=</span> <span class="n">_try_kind_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">good</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">ascending</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ascending</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Length of ascending (</span><span class="si">%d</span><span class="s1">) must be 1 &#39;</span>
                                 <span class="s1">&#39;for Series&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ascending</span><span class="p">)))</span>
            <span class="n">ascending</span> <span class="o">=</span> <span class="n">ascending</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_bool</span><span class="p">(</span><span class="n">ascending</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;ascending must be boolean&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">ascending</span><span class="p">:</span>
            <span class="n">argsorted</span> <span class="o">=</span> <span class="n">argsorted</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">na_position</span> <span class="o">==</span> <span class="s1">&#39;last&#39;</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">good</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">sortedIdx</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">good</span><span class="p">][</span><span class="n">argsorted</span><span class="p">]</span>
            <span class="n">sortedIdx</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">bad</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">na_position</span> <span class="o">==</span> <span class="s1">&#39;first&#39;</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">bad</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">sortedIdx</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">good</span><span class="p">][</span><span class="n">argsorted</span><span class="p">]</span>
            <span class="n">sortedIdx</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">bad</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid na_position: </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">na_position</span><span class="p">))</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">sortedIdx</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">sortedIdx</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sort_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;quicksort&#39;</span><span class="p">,</span> <span class="n">na_position</span><span class="o">=</span><span class="s1">&#39;last&#39;</span><span class="p">,</span> <span class="n">sort_remaining</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort Series by index labels.</span>

<span class="sd">        Returns a new Series sorted by label if `inplace` argument is</span>
<span class="sd">        ``False``, otherwise updates the original series and returns None.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : int, default 0</span>
<span class="sd">            Axis to direct sorting. This can only be 0 for Series.</span>
<span class="sd">        level : int, optional</span>
<span class="sd">            If not None, sort on values in specified index level(s).</span>
<span class="sd">        ascending : bool, default true</span>
<span class="sd">            Sort ascending vs. descending.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            If True, perform operation in-place.</span>
<span class="sd">        kind : {&#39;quicksort&#39;, &#39;mergesort&#39;, &#39;heapsort&#39;}, default &#39;quicksort&#39;</span>
<span class="sd">            Choice of sorting algorithm. See also :func:`numpy.sort` for more</span>
<span class="sd">            information.  &#39;mergesort&#39; is the only stable algorithm. For</span>
<span class="sd">            DataFrames, this option is only applied when sorting on a single</span>
<span class="sd">            column or label.</span>
<span class="sd">        na_position : {&#39;first&#39;, &#39;last&#39;}, default &#39;last&#39;</span>
<span class="sd">            If &#39;first&#39; puts NaNs at the beginning, &#39;last&#39; puts NaNs at the end.</span>
<span class="sd">            Not implemented for MultiIndex.</span>
<span class="sd">        sort_remaining : bool, default True</span>
<span class="sd">            If true and sorting by level and index is multilevel, sort by other</span>
<span class="sd">            levels too (in order) after sorting by specified level.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.Series</span>
<span class="sd">            The original Series sorted by the labels</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.sort_index: Sort DataFrame by the index</span>
<span class="sd">        DataFrame.sort_values: Sort DataFrame by the value</span>
<span class="sd">        Series.sort_values : Sort Series by the value</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], index=[3, 2, 1, 4])</span>
<span class="sd">        &gt;&gt;&gt; s.sort_index()</span>
<span class="sd">        1    c</span>
<span class="sd">        2    b</span>
<span class="sd">        3    a</span>
<span class="sd">        4    d</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Sort Descending</span>

<span class="sd">        &gt;&gt;&gt; s.sort_index(ascending=False)</span>
<span class="sd">        4    d</span>
<span class="sd">        3    a</span>
<span class="sd">        2    b</span>
<span class="sd">        1    c</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Sort Inplace</span>

<span class="sd">        &gt;&gt;&gt; s.sort_index(inplace=True)</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        1    c</span>
<span class="sd">        2    b</span>
<span class="sd">        3    a</span>
<span class="sd">        4    d</span>
<span class="sd">        dtype: object</span>

<span class="sd">        By default NaNs are put at the end, but use `na_position` to place</span>
<span class="sd">        them at the beginning</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], index=[3, 2, 1, np.nan])</span>
<span class="sd">        &gt;&gt;&gt; s.sort_index(na_position=&#39;first&#39;)</span>
<span class="sd">        NaN     d</span>
<span class="sd">         1.0    c</span>
<span class="sd">         2.0    b</span>
<span class="sd">         3.0    a</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Specify index level to sort</span>

<span class="sd">        &gt;&gt;&gt; arrays = [np.array([&#39;qux&#39;, &#39;qux&#39;, &#39;foo&#39;, &#39;foo&#39;,</span>
<span class="sd">        ...                     &#39;baz&#39;, &#39;baz&#39;, &#39;bar&#39;, &#39;bar&#39;]),</span>
<span class="sd">        ...           np.array([&#39;two&#39;, &#39;one&#39;, &#39;two&#39;, &#39;one&#39;,</span>
<span class="sd">        ...                     &#39;two&#39;, &#39;one&#39;, &#39;two&#39;, &#39;one&#39;])]</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 2, 3, 4, 5, 6, 7, 8], index=arrays)</span>
<span class="sd">        &gt;&gt;&gt; s.sort_index(level=1)</span>
<span class="sd">        bar  one    8</span>
<span class="sd">        baz  one    6</span>
<span class="sd">        foo  one    4</span>
<span class="sd">        qux  one    2</span>
<span class="sd">        bar  two    7</span>
<span class="sd">        baz  two    5</span>
<span class="sd">        foo  two    3</span>
<span class="sd">        qux  two    1</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        Does not sort by remaining levels when sorting by levels</span>

<span class="sd">        &gt;&gt;&gt; s.sort_index(level=1, sort_remaining=False)</span>
<span class="sd">        qux  one    2</span>
<span class="sd">        foo  one    4</span>
<span class="sd">        baz  one    6</span>
<span class="sd">        bar  one    8</span>
<span class="sd">        qux  two    1</span>
<span class="sd">        foo  two    3</span>
<span class="sd">        baz  two    5</span>
<span class="sd">        bar  two    7</span>
<span class="sd">        dtype: int64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: this can be combined with DataFrame.sort_index impl as</span>
        <span class="c1"># almost identical</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s1">&#39;inplace&#39;</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span>

        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_index</span><span class="p">,</span> <span class="n">indexer</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">sortlevel</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">,</span>
                                                 <span class="n">sort_remaining</span><span class="o">=</span><span class="n">sort_remaining</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">pandas.core.sorting</span> <span class="k">import</span> <span class="n">lexsort_indexer</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">_sort_levels_monotonic</span><span class="p">()</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="n">lexsort_indexer</span><span class="p">(</span><span class="n">labels</span><span class="o">.</span><span class="n">_get_labels_for_sorting</span><span class="p">(),</span>
                                      <span class="n">orders</span><span class="o">=</span><span class="n">ascending</span><span class="p">,</span>
                                      <span class="n">na_position</span><span class="o">=</span><span class="n">na_position</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">pandas.core.sorting</span> <span class="k">import</span> <span class="n">nargsort</span>

            <span class="c1"># Check monotonic-ness before sort an index</span>
            <span class="c1"># GH11080</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">ascending</span> <span class="ow">and</span> <span class="n">index</span><span class="o">.</span><span class="n">is_monotonic_increasing</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="p">(</span><span class="ow">not</span> <span class="n">ascending</span> <span class="ow">and</span> <span class="n">index</span><span class="o">.</span><span class="n">is_monotonic_decreasing</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="n">indexer</span> <span class="o">=</span> <span class="n">nargsort</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">,</span>
                               <span class="n">na_position</span><span class="o">=</span><span class="n">na_position</span><span class="p">)</span>

        <span class="n">indexer</span> <span class="o">=</span> <span class="n">_ensure_platform_int</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span>
        <span class="n">new_index</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span>
        <span class="n">new_index</span> <span class="o">=</span> <span class="n">new_index</span><span class="o">.</span><span class="n">_sort_levels_monotonic</span><span class="p">()</span>

        <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">argsort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;quicksort&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overrides ndarray.argsort. Argsorts the value, omitting NA/null values,</span>
<span class="sd">        and places the result in the same locations as the non-NA values</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : int (can only be zero)</span>
<span class="sd">        kind : {&#39;mergesort&#39;, &#39;quicksort&#39;, &#39;heapsort&#39;}, default &#39;quicksort&#39;</span>
<span class="sd">            Choice of sorting algorithm. See np.sort for more</span>
<span class="sd">            information. &#39;mergesort&#39; is the only stable algorithm</span>
<span class="sd">        order : ignored</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        argsorted : Series, with -1 indicated where nan values are present</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.ndarray.argsort</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">isna</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                            <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int64&#39;</span><span class="p">)</span>
            <span class="n">notmask</span> <span class="o">=</span> <span class="o">~</span><span class="n">mask</span>
            <span class="n">result</span><span class="p">[</span><span class="n">notmask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">notmask</span><span class="p">],</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span>
                                     <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int64&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">nlargest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the largest `n` elements.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int</span>
<span class="sd">            Return this many descending sorted values</span>
<span class="sd">        keep : {&#39;first&#39;, &#39;last&#39;}, default &#39;first&#39;</span>
<span class="sd">            Where there are duplicate values:</span>
<span class="sd">            - ``first`` : take the first occurrence.</span>
<span class="sd">            - ``last`` : take the last occurrence.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        top_n : Series</span>
<span class="sd">            The n largest values in the Series, in sorted order</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Faster than ``.sort_values(ascending=False).head(n)`` for small `n`</span>
<span class="sd">        relative to the size of the ``Series`` object.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.nsmallest</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series(np.random.randn(10**6))</span>
<span class="sd">        &gt;&gt;&gt; s.nlargest(10)  # only sorts up to the N requested</span>
<span class="sd">        219921    4.644710</span>
<span class="sd">        82124     4.608745</span>
<span class="sd">        421689    4.564644</span>
<span class="sd">        425277    4.447014</span>
<span class="sd">        718691    4.414137</span>
<span class="sd">        43154     4.403520</span>
<span class="sd">        283187    4.313922</span>
<span class="sd">        595519    4.273635</span>
<span class="sd">        503969    4.250236</span>
<span class="sd">        121637    4.240952</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">algorithms</span><span class="o">.</span><span class="n">SelectNSeries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="n">keep</span><span class="p">)</span><span class="o">.</span><span class="n">nlargest</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">nsmallest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the smallest `n` elements.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int</span>
<span class="sd">            Return this many ascending sorted values</span>
<span class="sd">        keep : {&#39;first&#39;, &#39;last&#39;}, default &#39;first&#39;</span>
<span class="sd">            Where there are duplicate values:</span>
<span class="sd">            - ``first`` : take the first occurrence.</span>
<span class="sd">            - ``last`` : take the last occurrence.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bottom_n : Series</span>
<span class="sd">            The n smallest values in the Series, in sorted order</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Faster than ``.sort_values().head(n)`` for small `n` relative to</span>
<span class="sd">        the size of the ``Series`` object.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.nlargest</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series(np.random.randn(10**6))</span>
<span class="sd">        &gt;&gt;&gt; s.nsmallest(10)  # only sorts up to the N requested</span>
<span class="sd">        288532   -4.954580</span>
<span class="sd">        732345   -4.835960</span>
<span class="sd">        64803    -4.812550</span>
<span class="sd">        446457   -4.609998</span>
<span class="sd">        501225   -4.483945</span>
<span class="sd">        669476   -4.472935</span>
<span class="sd">        973615   -4.401699</span>
<span class="sd">        621279   -4.355126</span>
<span class="sd">        773916   -4.347355</span>
<span class="sd">        359919   -4.331927</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">algorithms</span><span class="o">.</span><span class="n">SelectNSeries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="n">keep</span><span class="p">)</span><span class="o">.</span><span class="n">nsmallest</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">sortlevel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sort_remaining</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sort Series with MultiIndex by chosen level. Data will be</span>
<span class="sd">        lexicographically sorted by the chosen level followed by the other</span>
<span class="sd">        levels (in order),</span>

<span class="sd">        .. deprecated:: 0.20.0</span>
<span class="sd">            Use :meth:`Series.sort_index`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        level : int or level name, default None</span>
<span class="sd">        ascending : bool, default True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sorted : Series</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.sort_index(level=...)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;sortlevel is deprecated, use sort_index(level=...)&quot;</span><span class="p">,</span>
                      <span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">,</span>
                               <span class="n">sort_remaining</span><span class="o">=</span><span class="n">sort_remaining</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">swaplevel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">j</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Swap levels i and j in a MultiIndex</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i, j : int, string (can be mixed)</span>
<span class="sd">            Level of index to be swapped. Can pass level name as string.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        swapped : Series</span>

<span class="sd">        .. versionchanged:: 0.18.1</span>

<span class="sd">           The indexes ``i`` and ``j`` are now optional, and default to</span>
<span class="sd">           the two innermost levels of the index.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">swaplevel</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">,</span>
                                 <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reorder_levels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rearrange index levels using input order. May not drop or duplicate</span>
<span class="sd">        levels</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order : list of int representing new level order.</span>
<span class="sd">               (reference level by number or key)</span>
<span class="sd">        axis : where to reorder levels</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        type of caller (new object)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Can only reorder levels on a hierarchical axis.&#39;</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">result</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">reorder_levels</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">unstack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unstack, a.k.a. pivot, Series with MultiIndex to produce DataFrame.</span>
<span class="sd">        The level involved will automatically get sorted.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        level : int, string, or list of these, default last level</span>
<span class="sd">            Level(s) to unstack, can pass level name</span>
<span class="sd">        fill_value : replace NaN with this value if the unstack produces</span>
<span class="sd">            missing values</span>

<span class="sd">            .. versionadded:: 0.18.0</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 2, 3, 4],</span>
<span class="sd">        ...     index=pd.MultiIndex.from_product([[&#39;one&#39;, &#39;two&#39;], [&#39;a&#39;, &#39;b&#39;]]))</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        one  a    1</span>
<span class="sd">             b    2</span>
<span class="sd">        two  a    3</span>
<span class="sd">             b    4</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; s.unstack(level=-1)</span>
<span class="sd">             a  b</span>
<span class="sd">        one  1  2</span>
<span class="sd">        two  3  4</span>

<span class="sd">        &gt;&gt;&gt; s.unstack(level=0)</span>
<span class="sd">           one  two</span>
<span class="sd">        a    1    3</span>
<span class="sd">        b    2    4</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unstacked : DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.reshape.reshape</span> <span class="k">import</span> <span class="n">unstack</span>
        <span class="k">return</span> <span class="n">unstack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># function application</span>

    <span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">na_action</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Map values of Series using input correspondence (a dict, Series, or</span>
<span class="sd">        function).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arg : function, dict, or Series</span>
<span class="sd">            Mapping correspondence.</span>
<span class="sd">        na_action : {None, &#39;ignore&#39;}</span>
<span class="sd">            If &#39;ignore&#39;, propagate NA values, without passing them to the</span>
<span class="sd">            mapping correspondence.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y : Series</span>
<span class="sd">            Same index as caller.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Map inputs to outputs (both of type `Series`):</span>

<span class="sd">        &gt;&gt;&gt; x = pd.Series([1,2,3], index=[&#39;one&#39;, &#39;two&#39;, &#39;three&#39;])</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        one      1</span>
<span class="sd">        two      2</span>
<span class="sd">        three    3</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; y = pd.Series([&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;], index=[1,2,3])</span>
<span class="sd">        &gt;&gt;&gt; y</span>
<span class="sd">        1    foo</span>
<span class="sd">        2    bar</span>
<span class="sd">        3    baz</span>

<span class="sd">        &gt;&gt;&gt; x.map(y)</span>
<span class="sd">        one   foo</span>
<span class="sd">        two   bar</span>
<span class="sd">        three baz</span>

<span class="sd">        If `arg` is a dictionary, return a new Series with values converted</span>
<span class="sd">        according to the dictionary&#39;s mapping:</span>

<span class="sd">        &gt;&gt;&gt; z = {1: &#39;A&#39;, 2: &#39;B&#39;, 3: &#39;C&#39;}</span>

<span class="sd">        &gt;&gt;&gt; x.map(z)</span>
<span class="sd">        one   A</span>
<span class="sd">        two   B</span>
<span class="sd">        three C</span>

<span class="sd">        Use na_action to control whether NA values are affected by the mapping</span>
<span class="sd">        function.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 2, 3, np.nan])</span>

<span class="sd">        &gt;&gt;&gt; s2 = s.map(&#39;this is a string {}&#39;.format, na_action=None)</span>
<span class="sd">        0    this is a string 1.0</span>
<span class="sd">        1    this is a string 2.0</span>
<span class="sd">        2    this is a string 3.0</span>
<span class="sd">        3    this is a string nan</span>
<span class="sd">        dtype: object</span>

<span class="sd">        &gt;&gt;&gt; s3 = s.map(&#39;this is a string {}&#39;.format, na_action=&#39;ignore&#39;)</span>
<span class="sd">        0    this is a string 1.0</span>
<span class="sd">        1    this is a string 2.0</span>
<span class="sd">        2    this is a string 3.0</span>
<span class="sd">        3                     NaN</span>
<span class="sd">        dtype: object</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.apply : For applying more complex functions on a Series.</span>
<span class="sd">        DataFrame.apply : Apply a function row-/column-wise.</span>
<span class="sd">        DataFrame.applymap : Apply a function elementwise on a whole DataFrame.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        When `arg` is a dictionary, values in Series that are not in the</span>
<span class="sd">        dictionary (as keys) are converted to ``NaN``. However, if the</span>
<span class="sd">        dictionary is a ``dict`` subclass that defines ``__missing__`` (i.e.</span>
<span class="sd">        provides a method for default values), then this default is used</span>
<span class="sd">        rather than ``NaN``:</span>

<span class="sd">        &gt;&gt;&gt; from collections import Counter</span>
<span class="sd">        &gt;&gt;&gt; counter = Counter()</span>
<span class="sd">        &gt;&gt;&gt; counter[&#39;bar&#39;] += 1</span>
<span class="sd">        &gt;&gt;&gt; y.map(counter)</span>
<span class="sd">        1    0</span>
<span class="sd">        2    1</span>
<span class="sd">        3    0</span>
<span class="sd">        dtype: int64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_values</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_map_values</span><span class="p">(</span>
            <span class="n">arg</span><span class="p">,</span> <span class="n">na_action</span><span class="o">=</span><span class="n">na_action</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span>
                                 <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_gotitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        sub-classes to define</span>
<span class="sd">        return a sliced object</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : string / list of selections</span>
<span class="sd">        ndim : 1,2</span>
<span class="sd">            requested ndim of result</span>
<span class="sd">        subset : object, default None</span>
<span class="sd">            subset to act on</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="n">_agg_doc</span> <span class="o">=</span> <span class="n">dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Examples</span>
<span class="s2">    --------</span>

<span class="s2">    &gt;&gt;&gt; s = Series(np.random.randn(10))</span>

<span class="s2">    &gt;&gt;&gt; s.agg(&#39;min&#39;)</span>
<span class="s2">    -1.3018049988556679</span>

<span class="s2">    &gt;&gt;&gt; s.agg([&#39;min&#39;, &#39;max&#39;])</span>
<span class="s2">    min   -1.301805</span>
<span class="s2">    max    1.127688</span>
<span class="s2">    dtype: float64</span>

<span class="s2">    See also</span>
<span class="s2">    --------</span>
<span class="s2">    pandas.Series.apply</span>
<span class="s2">    pandas.Series.transform</span>

<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_agg_doc</span><span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">generic</span><span class="o">.</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;aggregate&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">versionadded</span><span class="o">=</span><span class="s1">&#39;.. versionadded:: 0.20.0&#39;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">_shared_doc_kwargs</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">aggregate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">result</span><span class="p">,</span> <span class="n">how</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggregate</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="c1"># we can be called from an inner function which</span>
            <span class="c1"># passes this meta-data</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_axis&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_level&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="c1"># try a regular apply, this evaluates lambdas</span>
            <span class="c1"># row-by-row; however if the lambda is expected a Series</span>
            <span class="c1"># expression, e.g.: lambda x: x-x.quantile(0.25)</span>
            <span class="c1"># this will fail, so we can try a vectorized evaluation</span>

            <span class="c1"># we cannot FIRST try the vectorized evaluation, because</span>
            <span class="c1"># then .agg and .apply would have different semantics if the</span>
            <span class="c1"># operation is actually defined on the Series, e.g. str</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="n">agg</span> <span class="o">=</span> <span class="n">aggregate</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">convert_dtype</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Invoke function on values of Series. Can be ufunc (a NumPy function</span>
<span class="sd">        that applies to the entire Series) or a Python function that only works</span>
<span class="sd">        on single values</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : function</span>
<span class="sd">        convert_dtype : boolean, default True</span>
<span class="sd">            Try to find better dtype for elementwise function results. If</span>
<span class="sd">            False, leave as dtype=object</span>
<span class="sd">        args : tuple</span>
<span class="sd">            Positional arguments to pass to function in addition to the value</span>
<span class="sd">        Additional keyword arguments will be passed as keywords to the function</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y : Series or DataFrame if func returns a Series</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.map: For element-wise operations</span>
<span class="sd">        Series.agg: only perform aggregating type operations</span>
<span class="sd">        Series.transform: only perform transformating type operations</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Create a series with typical summer temperatures for each city.</span>

<span class="sd">        &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; series = pd.Series([20, 21, 12], index=[&#39;London&#39;,</span>
<span class="sd">        ... &#39;New York&#39;,&#39;Helsinki&#39;])</span>
<span class="sd">        &gt;&gt;&gt; series</span>
<span class="sd">        London      20</span>
<span class="sd">        New York    21</span>
<span class="sd">        Helsinki    12</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        Square the values by defining a function and passing it as an</span>
<span class="sd">        argument to ``apply()``.</span>

<span class="sd">        &gt;&gt;&gt; def square(x):</span>
<span class="sd">        ...     return x**2</span>
<span class="sd">        &gt;&gt;&gt; series.apply(square)</span>
<span class="sd">        London      400</span>
<span class="sd">        New York    441</span>
<span class="sd">        Helsinki    144</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        Square the values by passing an anonymous function as an</span>
<span class="sd">        argument to ``apply()``.</span>

<span class="sd">        &gt;&gt;&gt; series.apply(lambda x: x**2)</span>
<span class="sd">        London      400</span>
<span class="sd">        New York    441</span>
<span class="sd">        Helsinki    144</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        Define a custom function that needs additional positional</span>
<span class="sd">        arguments and pass these additional arguments using the</span>
<span class="sd">        ``args`` keyword.</span>

<span class="sd">        &gt;&gt;&gt; def subtract_custom_value(x, custom_value):</span>
<span class="sd">        ...     return x-custom_value</span>

<span class="sd">        &gt;&gt;&gt; series.apply(subtract_custom_value, args=(5,))</span>
<span class="sd">        London      15</span>
<span class="sd">        New York    16</span>
<span class="sd">        Helsinki     7</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        Define a custom function that takes keyword arguments</span>
<span class="sd">        and pass these arguments to ``apply``.</span>

<span class="sd">        &gt;&gt;&gt; def add_custom_values(x, **kwargs):</span>
<span class="sd">        ...     for month in kwargs:</span>
<span class="sd">        ...         x+=kwargs[month]</span>
<span class="sd">        ...     return x</span>

<span class="sd">        &gt;&gt;&gt; series.apply(add_custom_values, june=30, july=20, august=25)</span>
<span class="sd">        London      95</span>
<span class="sd">        New York    96</span>
<span class="sd">        Helsinki    87</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        Use a function from the Numpy library.</span>

<span class="sd">        &gt;&gt;&gt; series.apply(np.log)</span>
<span class="sd">        London      2.995732</span>
<span class="sd">        New York    3.044522</span>
<span class="sd">        Helsinki    2.484907</span>
<span class="sd">        dtype: float64</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                                     <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># dispatch to agg</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

        <span class="c1"># if we are a string, try to dispatch</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">compat</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_try_aggregate_string_function</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

        <span class="c1"># handle ufuncs and lambdas</span>
        <span class="k">if</span> <span class="n">kwds</span> <span class="ow">or</span> <span class="n">args</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ufunc</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">func</span>

        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ufunc</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

            <span class="c1"># row-wise access</span>
            <span class="k">if</span> <span class="n">is_extension_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                <span class="n">mapped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
                <span class="n">mapped</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">map_infer</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">convert</span><span class="o">=</span><span class="n">convert_dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mapped</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapped</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Series</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">pandas.core.frame</span> <span class="k">import</span> <span class="n">DataFrame</span>
            <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">mapped</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">mapped</span><span class="p">,</span>
                                     <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">filter_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        perform a reduction operation</span>

<span class="sd">        if we have an ndarray as a value, then simply perform the operation,</span>
<span class="sd">        otherwise delegate to the object</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">delegate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">delegate</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="c1"># Validate that &#39;axis&#39; is consistent with Series&#39;s single axis.</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">numeric_only</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Series.</span><span class="si">{0}</span><span class="s1"> does not implement &#39;</span>
                                          <span class="s1">&#39;numeric_only.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="n">delegate</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">delegate</span><span class="o">.</span><span class="n">_reduce</span><span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="n">op</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span>
                                <span class="n">numeric_only</span><span class="o">=</span><span class="n">numeric_only</span><span class="p">,</span>
                                <span class="n">filter_type</span><span class="o">=</span><span class="n">filter_type</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reindex_indexer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_index</span><span class="p">,</span> <span class="n">indexer</span><span class="p">,</span> <span class="n">copy</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">indexer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">new_values</span> <span class="o">=</span> <span class="n">algorithms</span><span class="o">.</span><span class="n">take_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">indexer</span><span class="p">,</span>
                                        <span class="n">allow_fill</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_needs_reindex_multi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; check if we do need a multi reindex; this is for compat with</span>
<span class="sd">        higher dims</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">generic</span><span class="o">.</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;align&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">align</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
              <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
              <span class="n">broadcast_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="n">join</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                                         <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                                         <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                         <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">fill_axis</span><span class="o">=</span><span class="n">fill_axis</span><span class="p">,</span>
                                         <span class="n">broadcast_axis</span><span class="o">=</span><span class="n">broadcast_axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Alter Series index labels or name</span>

<span class="sd">        Function / dict values must be unique (1-to-1). Labels not contained in</span>
<span class="sd">        a dict / Series will be left as-is. Extra labels listed don&#39;t throw an</span>
<span class="sd">        error.</span>

<span class="sd">        Alternatively, change ``Series.name`` with a scalar value.</span>

<span class="sd">        See the :ref:`user guide &lt;basics.rename&gt;` for more.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : scalar, hashable sequence, dict-like or function, optional</span>
<span class="sd">            dict-like or functions are transformations to apply to</span>
<span class="sd">            the index.</span>
<span class="sd">            Scalar or hashable sequence-like will alter the ``Series.name``</span>
<span class="sd">            attribute.</span>
<span class="sd">        copy : boolean, default True</span>
<span class="sd">            Also copy underlying data</span>
<span class="sd">        inplace : boolean, default False</span>
<span class="sd">            Whether to return a new Series. If True then value of copy is</span>
<span class="sd">            ignored.</span>
<span class="sd">        level : int or level name, default None</span>
<span class="sd">            In case of a MultiIndex, only rename labels in the specified</span>
<span class="sd">            level.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        renamed : Series (new object)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pandas.Series.rename_axis</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        2    3</span>
<span class="sd">        dtype: int64</span>
<span class="sd">        &gt;&gt;&gt; s.rename(&quot;my_name&quot;) # scalar, changes Series.name</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        2    3</span>
<span class="sd">        Name: my_name, dtype: int64</span>
<span class="sd">        &gt;&gt;&gt; s.rename(lambda x: x ** 2)  # function, changes labels</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        4    3</span>
<span class="sd">        dtype: int64</span>
<span class="sd">        &gt;&gt;&gt; s.rename({1: 3, 2: 5})  # mapping, changes labels</span>
<span class="sd">        0    1</span>
<span class="sd">        3    2</span>
<span class="sd">        5    3</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;inplace&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;inplace&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
                                                <span class="s1">&#39;inplace&#39;</span><span class="p">)</span>

        <span class="n">non_mapping</span> <span class="o">=</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">is_list_like</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="ow">and</span>
                                           <span class="ow">not</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">non_mapping</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_name</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;inplace&#39;</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">generic</span><span class="o">.</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;reindex&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">reindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">drop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return Series with specified index labels removed.</span>

<span class="sd">        Remove elements of a Series based on specifying the index labels.</span>
<span class="sd">        When using a multi-index, labels on different levels can be removed</span>
<span class="sd">        by specifying the level.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        labels : single label or list-like</span>
<span class="sd">            Index labels to drop.</span>
<span class="sd">        axis : 0, default 0</span>
<span class="sd">            Redundant for application on Series.</span>
<span class="sd">        index, columns : None</span>
<span class="sd">            Redundant for application on Series, but index can be used instead</span>
<span class="sd">            of labels.</span>

<span class="sd">            .. versionadded:: 0.21.0</span>
<span class="sd">        level : int or level name, optional</span>
<span class="sd">            For MultiIndex, level for which the labels will be removed.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            If True, do operation inplace and return None.</span>
<span class="sd">        errors : {&#39;ignore&#39;, &#39;raise&#39;}, default &#39;raise&#39;</span>
<span class="sd">            If &#39;ignore&#39;, suppress error and only existing labels are dropped.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dropped : pandas.Series</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.reindex : Return only specified index labels of Series.</span>
<span class="sd">        Series.dropna : Return series without null values.</span>
<span class="sd">        Series.drop_duplicates : Return Series with duplicate values removed.</span>
<span class="sd">        DataFrame.drop : Drop specified labels from rows or columns.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        KeyError</span>
<span class="sd">            If none of the labels are found in the index.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series(data=np.arange(3), index=[&#39;A&#39;,&#39;B&#39;,&#39;C&#39;])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        A  0</span>
<span class="sd">        B  1</span>
<span class="sd">        C  2</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        Drop labels B en C</span>

<span class="sd">        &gt;&gt;&gt; s.drop(labels=[&#39;B&#39;,&#39;C&#39;])</span>
<span class="sd">        A  0</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        Drop 2nd level label in MultiIndex Series</span>

<span class="sd">        &gt;&gt;&gt; midx = pd.MultiIndex(levels=[[&#39;lama&#39;, &#39;cow&#39;, &#39;falcon&#39;],</span>
<span class="sd">        ...                              [&#39;speed&#39;, &#39;weight&#39;, &#39;length&#39;]],</span>
<span class="sd">        ...                      labels=[[0, 0, 0, 1, 1, 1, 2, 2, 2],</span>
<span class="sd">        ...                              [0, 1, 2, 0, 1, 2, 0, 1, 2]])</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series([45, 200, 1.2, 30, 250, 1.5, 320, 1, 0.3],</span>
<span class="sd">        ...               index=midx)</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        lama    speed      45.0</span>
<span class="sd">                weight    200.0</span>
<span class="sd">                length      1.2</span>
<span class="sd">        cow     speed      30.0</span>
<span class="sd">                weight    250.0</span>
<span class="sd">                length      1.5</span>
<span class="sd">        falcon  speed     320.0</span>
<span class="sd">                weight      1.0</span>
<span class="sd">                length      0.3</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        &gt;&gt;&gt; s.drop(labels=&#39;weight&#39;, level=1)</span>
<span class="sd">        lama    speed      45.0</span>
<span class="sd">                length      1.2</span>
<span class="sd">        cow     speed      30.0</span>
<span class="sd">                length      1.5</span>
<span class="sd">        falcon  speed     320.0</span>
<span class="sd">                length      0.3</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
                                        <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                                        <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">)</span>

    <span class="nd">@Substitution</span><span class="p">(</span><span class="o">**</span><span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">generic</span><span class="o">.</span><span class="n">NDFrame</span><span class="o">.</span><span class="n">fillna</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fillna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                          <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
                                          <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span><span class="p">,</span>
                                          <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">generic</span><span class="o">.</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;replace&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_replace</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">regex</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;pad&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">to_replace</span><span class="o">=</span><span class="n">to_replace</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
                                           <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                                           <span class="n">regex</span><span class="o">=</span><span class="n">regex</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">generic</span><span class="o">.</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;shift&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">periods</span><span class="o">=</span><span class="n">periods</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reindex_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Conform Series to new index with optional filling logic.</span>

<span class="sd">        .. deprecated:: 0.21.0</span>
<span class="sd">            Use ``Series.reindex`` instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># for compatibility with higher dims</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot reindex series on non-zero axis!&quot;</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&#39;.reindex_axis&#39; is deprecated and will be removed in a future &quot;</span>
               <span class="s2">&quot;version. Use &#39;.reindex&#39; instead.&quot;</span><span class="p">)</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">memory_usage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the memory usage of the Series.</span>

<span class="sd">        The memory usage can optionally include the contribution of</span>
<span class="sd">        the index and of elements of `object` dtype.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : bool, default True</span>
<span class="sd">            Specifies whether to include the memory usage of the Series index.</span>
<span class="sd">        deep : bool, default False</span>
<span class="sd">            If True, introspect the data deeply by interrogating</span>
<span class="sd">            `object` dtypes for system-level memory consumption, and include</span>
<span class="sd">            it in the returned value.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Bytes of memory consumed.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.ndarray.nbytes : Total bytes consumed by the elements of the</span>
<span class="sd">            array.</span>
<span class="sd">        DataFrame.memory_usage : Bytes consumed by a DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series(range(3))</span>
<span class="sd">        &gt;&gt;&gt; s.memory_usage()</span>
<span class="sd">        104</span>

<span class="sd">        Not including the index gives the size of the rest of the data, which</span>
<span class="sd">        is necessarily smaller:</span>

<span class="sd">        &gt;&gt;&gt; s.memory_usage(index=False)</span>
<span class="sd">        24</span>

<span class="sd">        The memory footprint of `object` values is ignored by default:</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([&quot;a&quot;, &quot;b&quot;])</span>
<span class="sd">        &gt;&gt;&gt; s.values</span>
<span class="sd">        array([&#39;a&#39;, &#39;b&#39;], dtype=object)</span>
<span class="sd">        &gt;&gt;&gt; s.memory_usage()</span>
<span class="sd">        96</span>
<span class="sd">        &gt;&gt;&gt; s.memory_usage(deep=True)</span>
<span class="sd">        212</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">memory_usage</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">memory_usage</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">v</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">generic</span><span class="o">.</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;_take&#39;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">_take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">is_copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="n">_ensure_platform_int</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_categorical_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c1"># https://github.com/pandas-dev/pandas/issues/20664</span>
            <span class="c1"># TODO: remove when the default Categorical.take behavior changes</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">maybe_convert_indices</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)))</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;allow_fill&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">,</span>
                                    <span class="n">fastpath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="c1"># Maybe set copy if we didn&#39;t actually change the index.</span>
        <span class="k">if</span> <span class="n">is_copy</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)):</span>
                <span class="n">result</span><span class="o">.</span><span class="n">_set_is_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">isin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether `values` are contained in Series.</span>

<span class="sd">        Return a boolean Series showing whether each element in the Series</span>
<span class="sd">        matches an element in the passed sequence of `values` exactly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        values : set or list-like</span>
<span class="sd">            The sequence of values to test. Passing in a single string will</span>
<span class="sd">            raise a ``TypeError``. Instead, turn a single string into a</span>
<span class="sd">            list of one element.</span>

<span class="sd">            .. versionadded:: 0.18.1</span>

<span class="sd">              Support for values as a set.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        isin : Series (bool dtype)</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">          * If `values` is a string</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pandas.DataFrame.isin : equivalent method on DataFrame</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([&#39;lama&#39;, &#39;cow&#39;, &#39;lama&#39;, &#39;beetle&#39;, &#39;lama&#39;,</span>
<span class="sd">        ...                &#39;hippo&#39;], name=&#39;animal&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s.isin([&#39;cow&#39;, &#39;lama&#39;])</span>
<span class="sd">        0     True</span>
<span class="sd">        1     True</span>
<span class="sd">        2     True</span>
<span class="sd">        3    False</span>
<span class="sd">        4     True</span>
<span class="sd">        5    False</span>
<span class="sd">        Name: animal, dtype: bool</span>

<span class="sd">        Passing a single string as ``s.isin(&#39;lama&#39;)`` will raise an error. Use</span>
<span class="sd">        a list of one element instead:</span>

<span class="sd">        &gt;&gt;&gt; s.isin([&#39;lama&#39;])</span>
<span class="sd">        0     True</span>
<span class="sd">        1    False</span>
<span class="sd">        2     True</span>
<span class="sd">        3    False</span>
<span class="sd">        4     True</span>
<span class="sd">        5    False</span>
<span class="sd">        Name: animal, dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">algorithms</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">between</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">inclusive</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return boolean Series equivalent to left &lt;= series &lt;= right.</span>

<span class="sd">        This function returns a boolean vector containing `True` wherever the</span>
<span class="sd">        corresponding Series element is between the boundary values `left` and</span>
<span class="sd">        `right`. NA values are treated as `False`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        left : scalar</span>
<span class="sd">            Left boundary.</span>
<span class="sd">        right : scalar</span>
<span class="sd">            Right boundary.</span>
<span class="sd">        inclusive : bool, default True</span>
<span class="sd">            Include boundaries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            Each element will be a boolean.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function is equivalent to ``(left &lt;= ser) &amp; (ser &lt;= right)``</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pandas.Series.gt : Greater than of series and other</span>
<span class="sd">        pandas.Series.lt : Less than of series and other</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series([2, 0, 4, 8, np.nan])</span>

<span class="sd">        Boundary values are included by default:</span>

<span class="sd">        &gt;&gt;&gt; s.between(1, 4)</span>
<span class="sd">        0     True</span>
<span class="sd">        1    False</span>
<span class="sd">        2     True</span>
<span class="sd">        3    False</span>
<span class="sd">        4    False</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        With `inclusive` set to ``False`` boundary values are excluded:</span>

<span class="sd">        &gt;&gt;&gt; s.between(1, 4, inclusive=False)</span>
<span class="sd">        0     True</span>
<span class="sd">        1    False</span>
<span class="sd">        2    False</span>
<span class="sd">        3    False</span>
<span class="sd">        4    False</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        `left` and `right` can be any scalar value:</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([&#39;Alice&#39;, &#39;Bob&#39;, &#39;Carol&#39;, &#39;Eve&#39;])</span>
<span class="sd">        &gt;&gt;&gt; s.between(&#39;Anna&#39;, &#39;Daniel&#39;)</span>
<span class="sd">        0    False</span>
<span class="sd">        1     True</span>
<span class="sd">        2     True</span>
<span class="sd">        3    False</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inclusive</span><span class="p">:</span>
            <span class="n">lmask</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">&gt;=</span> <span class="n">left</span>
            <span class="n">rmask</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">&lt;=</span> <span class="n">right</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lmask</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">&gt;</span> <span class="n">left</span>
            <span class="n">rmask</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">&lt;</span> <span class="n">right</span>

        <span class="k">return</span> <span class="n">lmask</span> <span class="o">&amp;</span> <span class="n">rmask</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_csv</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">parse_dates</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">infer_datetime_format</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read CSV file.</span>

<span class="sd">        .. deprecated:: 0.21.0</span>
<span class="sd">            Use :func:`pandas.read_csv` instead.</span>

<span class="sd">        It is preferable to use the more powerful :func:`pandas.read_csv`</span>
<span class="sd">        for most general purposes, but ``from_csv`` makes for an easy</span>
<span class="sd">        roundtrip to and from a file (the exact counterpart of</span>
<span class="sd">        ``to_csv``), especially with a time Series.</span>

<span class="sd">        This method only differs from :func:`pandas.read_csv` in some defaults:</span>

<span class="sd">        - `index_col` is ``0`` instead of ``None`` (take first column as index</span>
<span class="sd">          by default)</span>
<span class="sd">        - `header` is ``None`` instead of ``0`` (the first row is not used as</span>
<span class="sd">          the column names)</span>
<span class="sd">        - `parse_dates` is ``True`` instead of ``False`` (try parsing the index</span>
<span class="sd">          as datetime by default)</span>

<span class="sd">        With :func:`pandas.read_csv`, the option ``squeeze=True`` can be used</span>
<span class="sd">        to return a Series like ``from_csv``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : string file path or file handle / StringIO</span>
<span class="sd">        sep : string, default &#39;,&#39;</span>
<span class="sd">            Field delimiter</span>
<span class="sd">        parse_dates : boolean, default True</span>
<span class="sd">            Parse dates. Different default from read_table</span>
<span class="sd">        header : int, default None</span>
<span class="sd">            Row to use as header (skip prior rows)</span>
<span class="sd">        index_col : int or sequence, default 0</span>
<span class="sd">            Column to use for index. If a sequence is given, a MultiIndex</span>
<span class="sd">            is used. Different default from read_table</span>
<span class="sd">        encoding : string, optional</span>
<span class="sd">            a string representing the encoding to use if the contents are</span>
<span class="sd">            non-ascii, for python versions prior to 3</span>
<span class="sd">        infer_datetime_format: boolean, default False</span>
<span class="sd">            If True and `parse_dates` is True for a column, try to infer the</span>
<span class="sd">            datetime format based on the first datetime string. If the format</span>
<span class="sd">            can be inferred, there often will be a large parsing speed-up.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        pandas.read_csv</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y : Series</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># We&#39;re calling `DataFrame.from_csv` in the implementation,</span>
        <span class="c1"># which will propagate a warning regarding `from_csv` deprecation.</span>
        <span class="kn">from</span> <span class="nn">pandas.core.frame</span> <span class="k">import</span> <span class="n">DataFrame</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="o">.</span><span class="n">from_csv</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="n">index_col</span><span class="p">,</span>
                                <span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">,</span> <span class="n">parse_dates</span><span class="o">=</span><span class="n">parse_dates</span><span class="p">,</span>
                                <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span>
                                <span class="n">infer_datetime_format</span><span class="o">=</span><span class="n">infer_datetime_format</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">to_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="n">na_rep</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
               <span class="n">float_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">date_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">decimal</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write Series to a comma-separated values (csv) file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : string or file handle, default None</span>
<span class="sd">            File path or object, if None is provided the result is returned as</span>
<span class="sd">            a string.</span>
<span class="sd">        na_rep : string, default &#39;&#39;</span>
<span class="sd">            Missing data representation</span>
<span class="sd">        float_format : string, default None</span>
<span class="sd">            Format string for floating point numbers</span>
<span class="sd">        header : boolean, default False</span>
<span class="sd">            Write out series name</span>
<span class="sd">        index : boolean, default True</span>
<span class="sd">            Write row names (index)</span>
<span class="sd">        index_label : string or sequence, default None</span>
<span class="sd">            Column label for index column(s) if desired. If None is given, and</span>
<span class="sd">            `header` and `index` are True, then the index names are used. A</span>
<span class="sd">            sequence should be given if the DataFrame uses MultiIndex.</span>
<span class="sd">        mode : Python write mode, default &#39;w&#39;</span>
<span class="sd">        sep : character, default &quot;,&quot;</span>
<span class="sd">            Field delimiter for the output file.</span>
<span class="sd">        encoding : string, optional</span>
<span class="sd">            a string representing the encoding to use if the contents are</span>
<span class="sd">            non-ascii, for python versions prior to 3</span>
<span class="sd">        compression : string, optional</span>
<span class="sd">            A string representing the compression to use in the output file.</span>
<span class="sd">            Allowed values are &#39;gzip&#39;, &#39;bz2&#39;, &#39;zip&#39;, &#39;xz&#39;. This input is only</span>
<span class="sd">            used when the first argument is a filename.</span>
<span class="sd">        date_format: string, default None</span>
<span class="sd">            Format string for datetime objects.</span>
<span class="sd">        decimal: string, default &#39;.&#39;</span>
<span class="sd">            Character recognized as decimal separator. E.g. use &#39;,&#39; for</span>
<span class="sd">            European data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.frame</span> <span class="k">import</span> <span class="n">DataFrame</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># result is only a string if no path provided, otherwise None</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">,</span> <span class="n">na_rep</span><span class="o">=</span><span class="n">na_rep</span><span class="p">,</span>
                           <span class="n">float_format</span><span class="o">=</span><span class="n">float_format</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span>
                           <span class="n">index_label</span><span class="o">=</span><span class="n">index_label</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                           <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">,</span>
                           <span class="n">date_format</span><span class="o">=</span><span class="n">date_format</span><span class="p">,</span> <span class="n">decimal</span><span class="o">=</span><span class="n">decimal</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">generic</span><span class="o">.</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;to_excel&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">to_excel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">excel_writer</span><span class="p">,</span> <span class="n">sheet_name</span><span class="o">=</span><span class="s1">&#39;Sheet1&#39;</span><span class="p">,</span> <span class="n">na_rep</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                 <span class="n">float_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">index_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">startrow</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">startcol</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">merge_cells</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inf_rep</span><span class="o">=</span><span class="s1">&#39;inf&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span>
        <span class="n">df</span><span class="o">.</span><span class="n">to_excel</span><span class="p">(</span><span class="n">excel_writer</span><span class="o">=</span><span class="n">excel_writer</span><span class="p">,</span> <span class="n">sheet_name</span><span class="o">=</span><span class="n">sheet_name</span><span class="p">,</span>
                    <span class="n">na_rep</span><span class="o">=</span><span class="n">na_rep</span><span class="p">,</span> <span class="n">float_format</span><span class="o">=</span><span class="n">float_format</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
                    <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">index_label</span><span class="o">=</span><span class="n">index_label</span><span class="p">,</span>
                    <span class="n">startrow</span><span class="o">=</span><span class="n">startrow</span><span class="p">,</span> <span class="n">startcol</span><span class="o">=</span><span class="n">startcol</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span>
                    <span class="n">merge_cells</span><span class="o">=</span><span class="n">merge_cells</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span>
                    <span class="n">inf_rep</span><span class="o">=</span><span class="n">inf_rep</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">generic</span><span class="o">.</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;isna&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">isna</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">generic</span><span class="o">.</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;isna&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">isnull</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">generic</span><span class="o">.</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;notna&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">notna</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">generic</span><span class="o">.</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;notna&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">notnull</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">notnull</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">dropna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new Series with missing values removed.</span>

<span class="sd">        See the :ref:`User Guide &lt;missing_data&gt;` for more on which values are</span>
<span class="sd">        considered missing, and how to work with missing data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {0 or &#39;index&#39;}, default 0</span>
<span class="sd">            There is only one axis to drop values from.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            If True, do operation inplace and return None.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Not in use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            Series with NA entries dropped from it.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.isna: Indicate missing values.</span>
<span class="sd">        Series.notna : Indicate existing (non-missing) values.</span>
<span class="sd">        Series.fillna : Replace missing values.</span>
<span class="sd">        DataFrame.dropna : Drop rows or columns which contain NA values.</span>
<span class="sd">        Index.dropna : Drop missing indices.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ser = pd.Series([1., 2., np.nan])</span>
<span class="sd">        &gt;&gt;&gt; ser</span>
<span class="sd">        0    1.0</span>
<span class="sd">        1    2.0</span>
<span class="sd">        2    NaN</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        Drop NA values from a Series.</span>

<span class="sd">        &gt;&gt;&gt; ser.dropna()</span>
<span class="sd">        0    1.0</span>
<span class="sd">        1    2.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        Keep the Series with valid entries in the same variable.</span>

<span class="sd">        &gt;&gt;&gt; ser.dropna(inplace=True)</span>
<span class="sd">        &gt;&gt;&gt; ser</span>
<span class="sd">        0    1.0</span>
<span class="sd">        1    2.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        Empty strings are not considered NA values. ``None`` is considered an</span>
<span class="sd">        NA value.</span>

<span class="sd">        &gt;&gt;&gt; ser = pd.Series([np.NaN, 2, pd.NaT, &#39;&#39;, None, &#39;I stay&#39;])</span>
<span class="sd">        &gt;&gt;&gt; ser</span>
<span class="sd">        0       NaN</span>
<span class="sd">        1         2</span>
<span class="sd">        2       NaT</span>
<span class="sd">        3</span>
<span class="sd">        4      None</span>
<span class="sd">        5    I stay</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &gt;&gt;&gt; ser.dropna()</span>
<span class="sd">        1         2</span>
<span class="sd">        3</span>
<span class="sd">        5    I stay</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s1">&#39;inplace&#39;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;how&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;dropna() got an unexpected keyword &#39;</span>
                            <span class="s1">&#39;argument &quot;</span><span class="si">{0}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_can_hold_na</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">remove_na_arraylike</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                <span class="c1"># do nothing</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">valid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return Series without null values.</span>

<span class="sd">        .. deprecated:: 0.23.0</span>
<span class="sd">            Use :meth:`Series.dropna` instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Method .valid will be removed in a future version. &quot;</span>
                      <span class="s2">&quot;Use .dropna instead.&quot;</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Time series-oriented methods</span>

    <span class="k">def</span> <span class="nf">to_timestamp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cast to datetimeindex of timestamps, at *beginning* of period</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq : string, default frequency of PeriodIndex</span>
<span class="sd">            Desired frequency</span>
<span class="sd">        how : {&#39;s&#39;, &#39;e&#39;, &#39;start&#39;, &#39;end&#39;}</span>
<span class="sd">            Convention for converting period to timestamp; start of period</span>
<span class="sd">            vs. end</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ts : Series with DatetimeIndex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="n">new_values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_timestamp</span><span class="p">(</span><span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span>
                                 <span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_period</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert Series from DatetimeIndex to PeriodIndex with desired</span>
<span class="sd">        frequency (inferred from index if not passed)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq : string, default</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ts : Series with PeriodIndex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="n">new_values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_period</span><span class="p">(</span><span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span>
                                 <span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Accessor Methods</span>
    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="nb">str</span> <span class="o">=</span> <span class="n">CachedAccessor</span><span class="p">(</span><span class="s2">&quot;str&quot;</span><span class="p">,</span> <span class="n">StringMethods</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">CachedAccessor</span><span class="p">(</span><span class="s2">&quot;dt&quot;</span><span class="p">,</span> <span class="n">CombinedDatetimelikeProperties</span><span class="p">)</span>
    <span class="n">cat</span> <span class="o">=</span> <span class="n">CachedAccessor</span><span class="p">(</span><span class="s2">&quot;cat&quot;</span><span class="p">,</span> <span class="n">CategoricalAccessor</span><span class="p">)</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="n">CachedAccessor</span><span class="p">(</span><span class="s2">&quot;plot&quot;</span><span class="p">,</span> <span class="n">gfx</span><span class="o">.</span><span class="n">SeriesPlotMethods</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Add plotting methods to Series</span>
    <span class="n">hist</span> <span class="o">=</span> <span class="n">gfx</span><span class="o">.</span><span class="n">hist_series</span>


<span class="n">Series</span><span class="o">.</span><span class="n">_setup_axes</span><span class="p">([</span><span class="s1">&#39;index&#39;</span><span class="p">],</span> <span class="n">info_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stat_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">aliases</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;rows&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span>
                   <span class="n">docs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;index&#39;</span><span class="p">:</span> <span class="s1">&#39;The index (axis labels) of the Series.&#39;</span><span class="p">})</span>
<span class="n">Series</span><span class="o">.</span><span class="n">_add_numeric_operations</span><span class="p">()</span>
<span class="n">Series</span><span class="o">.</span><span class="n">_add_series_only_operations</span><span class="p">()</span>
<span class="n">Series</span><span class="o">.</span><span class="n">_add_series_or_dataframe_operations</span><span class="p">()</span>

<span class="c1"># Add arithmetic!</span>
<span class="n">ops</span><span class="o">.</span><span class="n">add_flex_arithmetic_methods</span><span class="p">(</span><span class="n">Series</span><span class="p">)</span>
<span class="n">ops</span><span class="o">.</span><span class="n">add_special_arithmetic_methods</span><span class="p">(</span><span class="n">Series</span><span class="p">)</span>


<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># Supplementary functions</span>


<span class="k">def</span> <span class="nf">_sanitize_index</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; sanitize an index type to return an ndarray of the underlying, pass</span>
<span class="sd">    thru a non-Index</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Length of values does not match length of &#39;</span> <span class="s1">&#39;index&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ABCIndexClass</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">copy</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">PeriodIndex</span><span class="p">,</span> <span class="n">DatetimeIndex</span><span class="p">)):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_values</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>

        <span class="c1"># coerce datetimelike types</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">]:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">_sanitize_array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">_sanitize_array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">raise_cast_failure</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; sanitize input data to an ndarray, copy if specified, coerce to the</span>
<span class="sd">    dtype if specified</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">pandas_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="n">maybe_upcast</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_try_cast</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">take_fast_path</span><span class="p">):</span>

        <span class="c1"># perf shortcut as this is the most common case</span>
        <span class="k">if</span> <span class="n">take_fast_path</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">maybe_castable</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">copy</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">arr</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">subarr</span> <span class="o">=</span> <span class="n">maybe_cast_to_datetime</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
            <span class="c1"># Take care in creating object arrays (but iterators are not</span>
            <span class="c1"># supported):</span>
            <span class="k">if</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">is_list_like</span><span class="p">(</span><span class="n">subarr</span><span class="p">)</span> <span class="ow">and</span>
                                           <span class="ow">not</span> <span class="p">(</span><span class="n">is_iterator</span><span class="p">(</span><span class="n">subarr</span><span class="p">)</span> <span class="ow">or</span>
                                           <span class="nb">isinstance</span><span class="p">(</span><span class="n">subarr</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))):</span>
                <span class="n">subarr</span> <span class="o">=</span> <span class="n">construct_1d_object_array_from_listlike</span><span class="p">(</span><span class="n">subarr</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">is_extension_type</span><span class="p">(</span><span class="n">subarr</span><span class="p">):</span>
                <span class="n">subarr</span> <span class="o">=</span> <span class="n">construct_1d_ndarray_preserving_na</span><span class="p">(</span><span class="n">subarr</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span>
                                                            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_categorical_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
                <span class="c1"># We *do* allow casting to categorical, since we know</span>
                <span class="c1"># that Categorical is the only array type for &#39;category&#39;.</span>
                <span class="n">subarr</span> <span class="o">=</span> <span class="n">Categorical</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">.</span><span class="n">categories</span><span class="p">,</span>
                                     <span class="n">ordered</span><span class="o">=</span><span class="n">dtype</span><span class="o">.</span><span class="n">ordered</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">is_extension_array_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
                <span class="c1"># We don&#39;t allow casting to third party dtypes, since we don&#39;t</span>
                <span class="c1"># know what array belongs to which type.</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Cannot cast data to extension dtype &#39;</span><span class="si">{}</span><span class="s2">&#39;. &quot;</span>
                       <span class="s2">&quot;Pass the extension array directly.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">raise_cast_failure</span><span class="p">:</span>
                <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">subarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">subarr</span>

    <span class="c1"># GH #846</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Index</span><span class="p">,</span> <span class="n">Series</span><span class="p">)):</span>

        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">subarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># possibility of nan -&gt; garbage</span>
            <span class="k">if</span> <span class="n">is_float_dtype</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_integer_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">isna</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">subarr</span> <span class="o">=</span> <span class="n">_try_cast</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">copy</span><span class="p">:</span>
                    <span class="n">subarr</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">subarr</span> <span class="o">=</span> <span class="n">_try_cast</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
            <span class="c1"># don&#39;t coerce Index types</span>
            <span class="c1"># e.g. indexes can have different conversions (so don&#39;t fast path</span>
            <span class="c1"># them)</span>
            <span class="c1"># GH 6140</span>
            <span class="n">subarr</span> <span class="o">=</span> <span class="n">_sanitize_index</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># we will try to copy be-definition here</span>
            <span class="n">subarr</span> <span class="o">=</span> <span class="n">_try_cast</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ExtensionArray</span><span class="p">):</span>
        <span class="n">subarr</span> <span class="o">=</span> <span class="n">data</span>

        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">is_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Cannot coerce extension array to dtype &#39;</span><span class="si">{typ}</span><span class="s2">&#39;. &quot;</span>
                   <span class="s2">&quot;Do the coercion before passing to the constructor &quot;</span>
                   <span class="s2">&quot;instead.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">typ</span><span class="o">=</span><span class="n">dtype</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">subarr</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">subarr</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">subarr</span> <span class="o">=</span> <span class="n">_try_cast</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">raise_cast_failure</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                    <span class="k">raise</span>
                <span class="n">subarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
                <span class="n">subarr</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">maybe_convert_objects</span><span class="p">(</span><span class="n">subarr</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">subarr</span> <span class="o">=</span> <span class="n">maybe_convert_platform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="n">subarr</span> <span class="o">=</span> <span class="n">maybe_cast_to_datetime</span><span class="p">(</span><span class="n">subarr</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">range</span><span class="p">):</span>
        <span class="c1"># GH 16804</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">get_range_parameters</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int64&#39;</span><span class="p">)</span>
        <span class="n">subarr</span> <span class="o">=</span> <span class="n">_try_cast</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">subarr</span> <span class="o">=</span> <span class="n">_try_cast</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="c1"># scalar like, GH</span>
    <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">subarr</span><span class="p">,</span> <span class="s1">&#39;ndim&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
            <span class="n">subarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">data</span>

            <span class="c1"># figure out the dtype from the value (upcast if necessary)</span>
            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dtype</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">infer_dtype_from_scalar</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># need to possibly convert the value here</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">maybe_cast_to_datetime</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

            <span class="n">subarr</span> <span class="o">=</span> <span class="n">construct_1d_arraylike_from_scalar</span><span class="p">(</span>
                <span class="n">value</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">dtype</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">subarr</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

    <span class="c1"># the result that we want</span>
    <span class="k">elif</span> <span class="n">subarr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="c1"># a 1-element ndarray</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subarr</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">subarr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">subarr</span> <span class="o">=</span> <span class="n">construct_1d_arraylike_from_scalar</span><span class="p">(</span>
                    <span class="n">subarr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">subarr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">subarr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Data must be 1-dimensional&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">subarr</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">_asarray_tuplesafe</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># This is to prevent mixed-type Series getting all casted to</span>
    <span class="c1"># NumPy string type, e.g. NaN --&gt; &#39;-1#IND&#39;.</span>
    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">subarr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">compat</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
        <span class="c1"># GH 16605</span>
        <span class="c1"># If not empty convert the data to dtype</span>
        <span class="c1"># GH 19853: If data is a scalar, subarr has already the result</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">isna</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">subarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">subarr</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, MITRE

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../../',
              VERSION:'1.0a',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>